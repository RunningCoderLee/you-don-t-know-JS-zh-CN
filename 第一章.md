# You Don't Know JS: Up & Going
# 你不知道的JS: Up & Going
# Chapter 1: Into Programming（罗尧）
# 第一章：进入编程

Welcome to the *You Don't Know JS* (*YDKJS*) series.

欢迎来到*你不知道的JS系列* (*YDKJS*).

*Up & Going* is an introduction to several basic concepts of programming -- of course we lean toward JavaScript (often abbreviated JS) specifically -- and how to approach and understand the rest of the titles in this series. Especially if you're just getting into programming and/or JavaScript, this book will briefly explore what you need to get *up and going*.

*Up & Going*会介绍关于编程的几个基本概念--当然我们更倾向于JavaScript(简称为JS)--还有如何去理解这系列其余的标题。尤其如果您刚接触到编程或是JavaScript，这本书将简要探讨您将从*up and going*学到什么。

This book starts off explaining the basic principles of programming at a very high level. It's mostly intended if you are starting *YDKJS* with little to no prior programming experience, and are looking to these books to help get you started along a path to understanding programming through the lens of JavaScript.

这本书将用比较高的水平解释基本的编程原理。如果您在看*YDKJS*之前没有任何的编程经验，希望这些书可以帮助您以JavaScript为镜头开始沿着一条路径理解编程。

Chapter 1 should be approached as a quick overview of the things you'll want to learn more about and practice to get *into programming*. There are also many other fantastic programming introduction resources that can help you dig into these topics further, and I encourage you to learn from them in addition to this chapter.

第1章快速概括关于进入编程您想要了解和实践的东西。当然也有许多其他出色的编程介绍资源，可以帮助您进一步挖掘这些主题，我鼓励您除了本章也学习他们。

Once you feel comfortable with general programming basics, Chapter 2 will help guide you to a familiarity with JavaScript's flavor of programming. Chapter 2 introduces what JavaScript is about, but again, it's not a comprehensive guide -- that's what the rest of the *YDKJS* books are for!

一旦你能适应编程基础，第二章将帮助指导你熟悉JavaScript编程。第2章介绍了什么是JavaScript，但再一次说明，这本书不是一本全面的指南——这就是剩下的* YDKJS *书!

If you're already fairly comfortable with JavaScript, first check out Chapter 3 as a brief glimpse of what to expect from *YDKJS*, then jump right in!

如果你已经相当熟悉JavaScript，首先查看第3章，简要地看一下期望从* YDKJS *得到什么，然后开始学习！

## Code （罗尧）
## 代码

Let's start from the beginning.

让我们从头开始。

A program, often referred to as *source code* or just *code*, is a set of special instructions to tell the computer what tasks to perform. Usually code is saved in a text file, although with JavaScript you can also type code directly into a developer console in a browser, which we'll cover shortly.

计算机程序，通常被称为*源代码*或只是*代码*，是一组特殊的指令，告诉计算机要执行什么任务。 通常代码保存在文本文件中，尽管使用JavaScript，您也可以直接在浏览器的开发者控制台中输入代码，我们稍后将介绍。

The rules for valid format and combinations of instructions is called a *computer language*, sometimes referred to as its *syntax*, much the same as English tells you how to spell words and how to create valid sentences using words and punctuation.

有效格式和指令组合的规则被称为*计算机语言*，有时称为*语法*，与英语告诉你如何拼写单词和如何使用单词和标点创建有效的句子一样。

### Statements （罗尧）
### 语句

In a computer language, a group of words, numbers, and operators that performs a specific task is a *statement*. In JavaScript, a statement might look as follows:

在计算机语言中，执行特定任务的一组字符，数字和运算符是*语句*。 在JavaScript中，语句可能如下所示：

```js
a = b * 2;
```

The characters `a` and `b` are called *variables* (see "Variables"), which are like simple boxes you can store any of your stuff in. In programs, variables hold values (like the number `42`) to be used by the program. Think of them as symbolic placeholders for the values themselves.

字符`a`和`b`称为*变量*（参见“变量”），它们就像简单的容器，你可以存储任何东西。在程序中，变量保存的值（如数字42）被程序使用。把他们作为自己的值象征性的占位符。

By contrast, the `2` is just a value itself, called a *literal value*, because it stands alone without being stored in a variable.

相比之下，`2`只是一个值本身，称为*字面值*，因为它独立存在于变量中。

The `=` and `*` characters are *operators* (see "Operators") -- they perform actions with the values and variables such as assignment and mathematic multiplication.

`=`和`*`字符是*运算符*（参见“运算符”） -- 它们使用值和变量（如赋值和数学乘法）执行操作。

Most statements in JavaScript conclude with a semicolon (`;`) at the end.

JavaScript中的大多数语句最后都以分号（`;`）结束。

The statement `a = b * 2;` tells the computer, roughly, to get the current value stored in the variable `b`, multiply that value by `2`, then store the result back into another variable we call `a`.

语句`a = b * 2;`告诉计算机，获取存储在变量`b`中的当前值，将该值乘以`2`，然后将结果存入另一个变量`a`中 。

Programs are just collections of many such statements, which together describe all the steps that it takes to perform your program's purpose.

程序只是许多这样的语句的集合，它们一起描述了执行程序目的所需的所有步骤。

### Expressions （张静）

Statements are made up of one or more *expressions*. An expression is any reference to a variable or value, or a set of variable(s) and value(s) combined with operators.

For example:

```js
a = b * 2;
```

This statement has four expressions in it:

* `2` is a *literal value expression*
* `b` is a *variable expression*, which means to retrieve its current value
* `b * 2` is an *arithmetic expression*, which means to do the multiplication
* `a = b * 2` is an *assignment expression*, which means to assign the result of the `b * 2` expression to the variable `a` (more on assignments later)

A general expression that stands alone is also called an *expression statement*, such as the following:

```js
b * 2;
```

This flavor of expression statement is not very common or useful, as generally it wouldn't have any effect on the running of the program -- it would retrieve the value of `b` and multiply it by `2`, but then wouldn't do anything with that result.

A more common expression statement is a *call expression* statement (see "Functions"), as the entire statement is the function call expression itself:

```js
alert( a );
```

### Executing a Program （张静）

How do those collections of programming statements tell the computer what to do? The program needs to be *executed*, also referred to as *running the program*.

Statements like `a = b * 2` are helpful for developers when reading and writing, but are not actually in a form the computer can directly understand. So a special utility on the computer (either an *interpreter* or a *compiler*) is used to translate the code you write into commands a computer can understand.

For some computer languages, this translation of commands is typically done from top to bottom, line by line, every time the program is run, which is usually called *interpreting* the code.

For other languages, the translation is done ahead of time, called *compiling* the code, so when the program *runs* later, what's running is actually the already compiled computer instructions ready to go.

It's typically asserted that JavaScript is *interpreted*, because your JavaScript source code is processed each time it's run. But that's not entirely accurate. The JavaScript engine actually *compiles* the program on the fly and then immediately runs the compiled code.

**Note:** For more information on JavaScript compiling, see the first two chapters of the *Scope & Closures* title of this series.

## Try It Yourself （张静）

This chapter is going to introduce each programming concept with simple snippets of code, all written in JavaScript (obviously!).

It cannot be emphasized enough: while you go through this chapter -- and you may need to spend the time to go over it several times -- you should practice each of these concepts by typing the code yourself. The easiest way to do that is to open up the developer tools console in your nearest browser (Firefox, Chrome, IE, etc.).

**Tip:** Typically, you can launch the developer console with a keyboard shortcut or from a menu item. For more detailed information about launching and using the console in your favorite browser, see "Mastering The Developer Tools Console" (http://blog.teamtreehouse.com/mastering-developer-tools-console). To type multiple lines into the console at once, use `<shift> + <enter>` to move to the next new line. Once you hit `<enter>` by itself, the console will run everything you've just typed.

Let's get familiar with the process of running code in the console. First, I suggest opening up an empty tab in your browser. I prefer to do this by typing `about:blank` into the address bar. Then, make sure your developer console is open, as we just mentioned.

Now, type this code and see how it runs:

```js
a = 21;

b = a * 2;

console.log( b );
```

Typing the preceding code into the console in Chrome should produce something like the following:

<img src="fig1.png" width="500">

Go on, try it. The best way to learn programming is to start coding!

### Output （翠翠）

In the previous code snippet, we used `console.log(..)`. Briefly, let's look at what that line of code is all about.

You may have guessed, but that's exactly how we print text (aka *output* to the user) in the developer console. There are two characteristics of that statement that we should explain.

First, the `log( b )` part is referred to as a function call (see "Functions"). What's happening is we're handing the `b` variable to that function, which asks it to take the value of `b` and print it to the console.

Second, the `console.` part is an object reference where the `log(..)` function is located. We cover objects and their properties in more detail in Chapter 2.

Another way of creating output that you can see is to run an `alert(..)` statement. For example:

```js
alert( b );
```

If you run that, you'll notice that instead of printing the output to the console, it shows a popup "OK" box with the contents of the `b` variable. However, using `console.log(..)` is generally going to make learning about coding and running your programs in the console easier than using `alert(..)`, because you can output many values at once without interrupting the browser interface.

For this book, we'll use `console.log(..)` for output.

### Input （翠翠）

While we're discussing output, you may also wonder about *input* (i.e., receiving information from the user).

The most common way that happens is for the HTML page to show form elements (like text boxes) to a user that they can type into, and then using JS to read those values into your program's variables.

But there's an easier way to get input for simple learning and demonstration purposes such as what you'll be doing throughout this book. Use the `prompt(..)` function:

```js
age = prompt( "Please tell me your age:" );

console.log( age );
```

As you may have guessed, the message you pass to `prompt(..)` -- in this case, `"Please tell me your age:"` -- is printed into the popup.

This should look similar to the following:

<img src="fig2.png" width="500">

Once you submit the input text by clicking "OK," you'll observe that the value you typed is stored in the `age` variable, which we then *output* with `console.log(..)`:

<img src="fig3.png" width="500">

To keep things simple while we're learning basic programming concepts, the examples in this book will not require input. But now that you've seen how to use `prompt(..)`, if you want to challenge yourself you can try to use input in your explorations of the examples.

## Operators （翠翠）

Operators are how we perform actions on variables and values. We've already seen two JavaScript operators, the `=` and the `*`.

The `*` operator performs mathematic multiplication. Simple enough, right?

The `=` equals operator is used for *assignment* -- we first calculate the value on the *right-hand side* (source value) of the `=` and then put it into the variable that we specify on the *left-hand side* (target variable).

**Warning:** This may seem like a strange reverse order to specify assignment. Instead of `a = 42`, some might prefer to flip the order so the source value is on the left and the target variable is on the right, like `42 -> a` (this is not valid JavaScript!). Unfortunately, the `a = 42` ordered form, and similar variations, is quite prevalent in modern programming languages. If it feels unnatural, just spend some time rehearsing that ordering in your mind to get accustomed to it.

Consider:

```js
a = 2;
b = a + 1;
```

Here, we assign the `2` value to the `a` variable. Then, we get the value of the `a` variable (still `2`), add `1` to it resulting in the value `3`, then store that value in the `b` variable.

While not technically an operator, you'll need the keyword `var` in every program, as it's the primary way you *declare* (aka *create*) *var*iables (see "Variables").

You should always declare the variable by name before you use it. But you only need to declare a variable once for each *scope* (see "Scope"); it can be used as many times after that as needed. For example:

```js
var a = 20;

a = a + 1;
a = a * 2;

console.log( a );	// 42
```

Here are some of the most common operators in JavaScript:

* Assignment: `=` as in `a = 2`.
* Math: `+` (addition), `-` (subtraction), `*` (multiplication), and `/` (division), as in `a * 3`.
* Compound Assignment: `+=`, `-=`, `*=`, and `/=` are compound operators that combine a math operation with assignment, as in `a += 2` (same as `a = a + 2`).
* Increment/Decrement: `++` (increment), `--` (decrement), as in `a++` (similar to `a = a + 1`).
* Object Property Access: `.` as in `console.log()`.

   Objects are values that hold other values at specific named locations called properties. `obj.a` means an object value called `obj` with a property of the name `a`. Properties can alternatively be accessed as `obj["a"]`. See Chapter 2.
* Equality: `==` (loose-equals), `===` (strict-equals), `!=` (loose not-equals), `!==` (strict not-equals), as in `a == b`.

   See "Values & Types" and Chapter 2.
* Comparison: `<` (less than), `>` (greater than), `<=` (less than or loose-equals), `>=` (greater than or loose-equals), as in `a <= b`.

   See "Values & Types" and Chapter 2.
* Logical: `&&` (and), `||` (or), as in `a || b` that selects either `a` *or* `b`.

   These operators are used to express compound conditionals (see "Conditionals"), like if either `a` *or* `b` is true.

**Note:** For much more detail, and coverage of operators not mentioned here, see the Mozilla Developer Network (MDN)'s "Expressions and Operators" (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators).

## 值和类型 （张雪）

如果你在手机店问店员某个手机的价格，店员会说：“九十九点九九”（$99.99），他们给你一个确定的美元数值，这个数值代表你购买时需要支付的金额。如果你要买两部这样的手机，你也能够轻松地心算出结果，所需花费两倍的手机单价，即$199.98。
If you ask an employee at a phone store how much a certain phone costs, and they say "ninety-nine, ninety-nine" (i.e., $99.99), they're giving you an actual numeric dollar figure that represents what you'll need to pay (plus taxes) to buy it. If you want to buy two of those phones, you can easily do the mental math to double that value to get $199.98 for your base cost.

如果店员拿起另一个相似的手机，而且说这种手机是“免费的”（也许并不真的是），这个时候，店员给出的并不是一个具体数字，而是给你一个代表该你所需花费（$0.00）的符号:"免费".
If that same employee picks up another similar phone but says it's "free" (perhaps with air quotes), they're not giving you a number, but instead another kind of representation of your expected cost ($0.00) -- the word "free."

当你问你这个手机是否包含一个充电器的时候，店员的回答只能有两种：是或否。
When you later ask if the phone includes a charger, that answer could only have been either "yes" or "no."

相似地，当你在程序中使用某些值时，你需要根据值的用途选择相应的符号来表示这些值。
In very similar ways, when you express values in a program, you choose different representations for those values based on what you plan to do with them.

这些对于值的不同表示方法在编程中有个专业的术语，叫做*类型*。JavaScript内置了很多类型，这些类型的值叫做 *原始（原生）* 值
These different representations for values are called *types* in programming terminology. JavaScript has built-in types for each of these so called *primitive* values:


* 你要做数学运算时，你需要`number`类型，即数值类型
* 你要在屏幕上输出时，你需要`string`类型，即字符串类型（可以是一个或多个字符，句子等）
* 你要在程序中作出决定时，你需要`boolean`类型，即布尔类型（可以是`true` 或 `false`）
* When you need to do math, you want a `number`.
* When you need to print a value on the screen, you need a `string` (one or more characters, words, sentences).
* When you need to make a decision in your program, you need a `boolean` (`true` or `false`).

当值被直接使用在源代码里时，称作 *字面量* ，字符串类型字面量被一对双引号`"..."`或一对单引号`'...'`包裹，两种使用方法的区别只有书写风格不同。`number` 和 `boolean`字面量直接使用即可（如`42`, `true`等等）。
Values that are included directly in the source code are called *literals*. `string` literals are surrounded by double quotes `"..."` or single quotes (`'...'`) -- the only difference is stylistic preference. `number` and `boolean` literals are just presented as is (i.e., `42`, `true`, etc.).

如下:

```js
"I am a string";
'I am also a string';

42;

true;
false;
```

除了 `string`/`number`/`boolean` 这样的值类型, 编程语言通常还提供*arrays*（数组）, *objects*（对象）, *functions*（函数）等类型. 我们将在本节和之后的章节详细介绍到这些类型。
Beyond `string`/`number`/`boolean` value types, it's common for programming languages to provide *arrays*, *objects*, *functions*, and more. We'll cover much more about values and types throughout this chapter and the next.

### 类型转换 （张雪）

如果你有一个`数值类型`的变量，但需要屏幕上输出，你就需要把这个值转换成`字符串类型`，在JavaScript中这种转换叫做“强制转换”，类似地，如果有人在页面上的表单里输入了一串数字字符，这些数字字符是`字符串类型`，如果你需要用这些数字字符做数学运算，你就需要把它*强制转换*成`数值类型`
If you have a `number` but need to print it on the screen, you need to convert the value to a `string`, and in JavaScript this conversion is called "coercion." Similarly, if someone enters a series of numeric characters into a form on an ecommerce page, that's a `string`, but if you need to then use that value to do math operations, you need to *coerce* it to a `number`.

JavaScript提供了几种不同的强制转化 *类型* 的方法，例如：
JavaScript provides several different facilities for forcibly coercing between *types*. For example:

```js
var a = "42";
var b = Number( a );

console.log( a );	// "42"
console.log( b );	// 42
```
使用`Number(..)`（一个JavaScript内建函数）把其他类型转换成`数值类型`的方法称之为*显式转换*，这种方法比较直接。
Using `Number(..)` (a built-in function) as shown is an *explicit* coercion from any other type to the `number` type. That should be pretty straightforward.

但这里有一个有争议性的话题：当你试图比较两种不同类型的值时，发生了什么事情？这种时候类型就会*隐式转换*
But a controversial topic is what happens when you try to compare two values that are not already of the same type, which would require *implicit* coercion.

当一个字符串`"99.99"`和数值`99.99`比较时，大多数人会认为他们是相等的。但准确地说，他们其实是不相等的，不是吗？这是同一个值的两种不同类型，你可以称之为“宽松相等”。
When comparing the string `"99.99"` to the number `99.99`, most people would agree they are equivalent. But they're not exactly the same, are they? It's the same value in two different representations, two different *types*. You could say they're "loosely equal," couldn't you?

为了在这种情况下给你提供便利，JavaScript有时会使用隐式转换后的值来进行比较。
To help you out in these common situations, JavaScript will sometimes kick in and *implicitly* coerce values to the matching types.

所以，如果你用`==`宽松相等运算符去比较 `"99.99" == 99.99`，JavaScript会把左侧的`"99.99"`转换成和它等值的`number`类型。此时，比较操作变成了`99.99 == 99.99`，结果也就是`true`。
So if you use the `==` loose equals operator to make the comparison `"99.99" == 99.99`, JavaScript will convert the left-hand side `"99.99"` to its `number` equivalent `99.99`. The comparison then becomes `99.99 == 99.99`, which is of course `true`.

虽然隐式转换被设计成可以帮助你，但如果你并没有花时间去学习其中的规则，就可能产生困惑。很多JS开发者从来没去了解过隐式转换的规则，以至于大多数人认为隐式转换令人困惑并有可能造成程序错误，因此应该避免使用。有时隐式转换甚至被称作一种语言缺陷。
While designed to help you, implicit coercion can create confusion if you haven't taken the time to learn the rules that govern its behavior. Most JS developers never have, so the common feeling is that implicit coercion is confusing and harms programs with unexpected bugs, and should thus be avoided. It's even sometimes called a flaw in the design of the language.

经过如此，影视转换依然是一种可以 *被学习* 的机制，而且 *应该被* 任何认真对待JavaScript的人学习。学了之后，你不仅不会被这些规则迷惑，还能让你的程序更棒。其中的努力还是很值得的。
However, implicit coercion is a mechanism that *can be learned*, and moreover *should be learned* by anyone wishing to take JavaScript programming seriously. Not only is it not confusing once you learn the rules, it can actually make your programs better! The effort is well worth it.

**注意：** 关于更多隐式转换的信息，见第二章相关内容和第四章的 *类型和语法* 系列。
**Note:** For more information on coercion, see Chapter 2 of this title and Chapter 4 of the *Types & Grammar* title of this series.

## 代码注释（张雪）

手机店店员可能会对新发布手机的特性或者公司推出的新计划写下一些笔记，这些笔记只有店员能看，顾客是不准看的。尽管如此，这些笔记记录了如何以及为什么他要给顾客讲这些。
The phone store employee might jot down some notes on the features of a newly released phone or on the new plans her company offers. These notes are only for the employee -- they're not for customers to read. Nevertheless, these notes help the employee do her job better by documenting the hows and whys of what she should tell customers.

关于编写代码，有一件重要的事情你需要知道，写出的代码不仅是给电脑的，每一段代码，也是提供给开发者和编译器的。
One of the most important lessons you can learn about writing code is that it's not just for the computer. Code is every bit as much, if not more, for the developer as it is for the compiler.

你的电脑只懂得机器码，一系列二进制的0和1，这些机器码是通过 *编译* 得到的。程序有很多种写法可以编译出相同的机器码。你所选择写程序的方式对你自己，你的团队成员，甚至是对于你的未来，都很重要。
Your computer only cares about machine code, a series of binary 0s and 1s, that comes from *compilation*. There's a nearly infinite number of programs you could write that yield the same series of 0s and 1s. The choices you make about how to write your program matter -- not only to you, but to your other team members and even to your future self.

你写的程序不应该仅仅是能正确运行，你更应该努力去写出检测复查时看起来十分合理的程序。要做的这一点，你需要付出长时间的努力，先从选择合适的变量（见“变量”一节）名和函数（见“函数”一节）名开始。
You should strive not just to write programs that work correctly, but programs that make sense when examined. You can go a long way in that effort by choosing good names for your variables (see "Variables") and functions (see "Functions").

另一件重要的事情就是代码注释。代码注释是你在代码中加入的一些列文本，这些文本纯粹是为了给看代码的人做解释。代码注释的部分会被编译器忽略。
But another important part is code comments. These are bits of text in your program that are inserted purely to explain things to a human. The interpreter/compiler will always ignore these comments.

对于如何写出注释优良的代码，有很多种观点；我们没办法定义绝对通用的规则，但下面这些观察实践和指导纲领是非常有用的。
There are lots of opinions on what makes well-commented code; we can't really define absolute universal rules. But some observations and guidelines are quite useful:

* 没有注释的代码不是最优的.
* 太多的注释（比如每行都有注释）可能是代码质量不佳的标志。
* 注释应该解释 *为什么* 而不是 *是什么*。注释只能在特别复杂困惑的地方选择性地解释 *如何做*。
* Code without comments is suboptimal.
* Too many comments (one per line, for example) is probably a sign of poorly written code.
* Comments should explain *why*, not *what*. They can optionally explain *how* if that's particularly confusing.

在JavaScript，有两种可能的注释方式：单行注释和多行注释。
In JavaScript, there are two types of comments possible: a single-line comment and a multiline comment.

如下：

```js
// 这是一条单行注释

/* 这是
       一条多行
             注释.
                      */
```

`//` 单行注释用在单个声明之上或在某行结束时非常合适。在每行的 `//` 之后的内容会被当成注释（因此会被编译器忽略），一直到该行结束。对于单行注释中的注释内容没有限制。
The `//` single-line comment is appropriate if you're going to put a comment right above a single statement, or even at the end of a line. Everything on the line after the `//` is treated as the comment (and thus ignored by the compiler), all the way to the end of the line. There's no restriction to what can appear inside a single-line comment.

如下
```js
var a = 42;		// 42 is the answer to life of the universe and everything
```

`/* .. */` 多行注释在你需要写若干行解释的时候非常有用。
The `/* .. */` multiline comment is appropriate if you have several lines worth of explanation to make in your comment.

下面是一些多行注释的用例：
Here's a common usage of multiline comments:

```js
/* The following value is used because
   it has been shown that it answers
   every question in the universe. */
var a = 42;
```

多行注释也可以在一行中的任意位置，甚至是在一行的中间，因为有`*/`来结束注释，例如：
It can also appear anywhere on a line, even in the middle of a line, because the `*/` ends it. For example:

```js
var a = /* arbitrary value */ 42;

console.log( a );	// 42
```

在多行注释的内容中只有`*/`不能出现，因为`*/`会被视为注释结束。
The only thing that cannot appear inside a multiline comment is a `*/`, because that would be interpreted to end the comment.

学习编程，你绝对应该从养成写注释开始。通读本章之后，你会发现我使用了注释去解释代码，你在自己的练习中可以做同样的注释。相信我，每一个度你代码的人都会感谢你的。
You will definitely want to begin your learning of programming by starting off with the habit of commenting code. Throughout the rest of this chapter, you'll see I use comments to explain things, so do the same in your own practice. Trust me, everyone who reads your code will thank you!
## 变量  ( 张润 )
变量：
因为某个值会某个根据程序的预处理任务不同而参与不同的操作，且在程序中不停的变化，
所以大多数的程序需要去追踪这个值。
在你的程序中，最简单的追踪方式是为这个值指派一个被称为变量的象征性的容器。
之所以被成为变量，是因为在容器中的这个值可以根据需要不断地更新。
在一些程序设计语言中，会声明一个变量(容器)来保存一个特殊类型的值，例如number或者string。

静态类型，同时也被称为强类型，一般通过防止非预期的值转换而被认为对程序的正确性有所裨益。
其他的强类型语言中的值取代了变量。弱类型和一些动态类型，允许在任何时候改变任何类型的值，
并且被认为是有助于程序的灵活性。
弱类型允许一个任何类型的可变值在程序逻辑流中被调用。
JavaScript则采用后一种方式，动态类型，这意味着变量可以保存任何类型的值，
并且没有任何类型的限制。如同早前提到的那样，我们会用var声明一个变量
注意，在声明中没有提到任何有关类型的信息。参考下面的程序：
var amount = 99.99;

amount = amount * 2;

console.log( amount );      // 199.98

// 将 `amount` 转变为string类型, 同时在开头添加"$"
amount = "$" + String( amount );

console.log( amount );      // "$199.98"

amount变量先开始存储数字99.99,然后保存结果是amount*2的number类型的数字，
也就是199.98，第一个console.log命令默认强制将number的值转换为了string类型输出。
然后 amount = "$" + String(amount)。
这句声明默认强制将199.98的值转换为string类型并为其开头添加了"$"符号。
现在，amout此时保存的的值是string“$199.98”,因此第二个console.log声明的输出不再需要再进行任何强制转换。

JavaScript的开发者需要注意amount变量为99.99,199.98，“$199.98”时值的灵活性。
喜欢使用静态类型的人更倾向于通过将最终的值“$199.98”，保存在amountStr中来分离变量，
因为最终结果是完全不同类型的值。
换句话说，状态即在程序运行时对所改变的值的追踪。变量的另一个常见用法是统一设置值，通常被称为constants，
用于声明一个有值的变量，而这个值又不会因为程序的运行而改变。
通常在程序的最前面声明constants,以便于日后需要的时候更改这些值。
按照惯例，JavaScript中的constants通常是通过下划线'_'连接的大写单词。

以下是一个简单的例子：
var TAX_RATE = 0.08;    // 8% sales tax

var amount = 99.99;

amount = amount * 2;

amount = amount + (amount * TAX_RATE);

console.log( amount );              // 215.9784
console.log( amount.toFixed( 2 ) ); // "215.98"
注释：类似于console.log中的log(..)方法是方位console对象中的一个属性，
toFixed(..)这个方法用于访问number类型的值。
JavaScript中的number类型不会自动转换为美元类型--机器不知道你的意图是什么，
也没有美元类型。
tofixed（..)方法让我们明确了我们需要number类型的数字四舍五入到几位小数点之后，
它还会在我们需要的时候将number类型转化为string类型输出。
常规情况下，TAX_RATE变量是唯一的常量--即程序中没有其他情况可以阻止它的改变.
但是如果城市税率提高到9%,我们仍旧可以简单的通过只修改TAX_RATE值为0.09来更新我们的程序。
而不是通过修改程序中多处0.08出现的地方来更新整个程序。

// as of ES6:
const TAX_RATE = 0.08;

var amount = 99.99;

// ..
除非常量被用作防止在初始化设置后数值突然改变的情况，其他情况下常量的用法如同不变的变量。
如果你试图在第一次声明以后的给TAX_RATE写入新的值，你的程序就会拒绝这种写入(同时在严格模式下，会报错--参看第二章的"严格模式")

顺便一提，针对错误的发生而出现的“保护”性措施类似于静态类型的强制性转换。
由此可见为什么静态类型在其它语言中会如此受欢迎。

NOTE: 关于更多有关程序中变量中值的区别，参考以Types & Grammar为主题的系列。 
## Variables （张润）

Most useful programs need to track a value as it changes over the course of the program, undergoing different operations as called for by your program's intended tasks.

The easiest way to go about that in your program is to assign a value to a symbolic container, called a *variable* -- so called because the value in this container can *vary* over time as needed.

In some programming languages, you declare a variable (container) to hold a specific type of value, such as `number` or `string`. *Static typing*, otherwise known as *type enforcement*, is typically cited as a benefit for program correctness by preventing unintended value conversions.

Other languages emphasize types for values instead of variables. *Weak typing*, otherwise known as *dynamic typing*, allows a variable to hold any type of value at any time. It's typically cited as a benefit for program flexibility by allowing a single variable to represent a value no matter what type form that value may take at any given moment in the program's logic flow.

JavaScript uses the latter approach, *dynamic typing*, meaning variables can hold values of any *type* without any *type* enforcement.

As mentioned earlier, we declare a variable using the `var` statement -- notice there's no other *type* information in the declaration. Consider this simple program:

```js
var amount = 99.99;

amount = amount * 2;

console.log( amount );		// 199.98

// convert `amount` to a string, and
// add "$" on the beginning
amount = "$" + String( amount );

console.log( amount );		// "$199.98"
```

The `amount` variable starts out holding the number `99.99`, and then holds the `number` result of `amount * 2`, which is `199.98`.

The first `console.log(..)` command has to *implicitly* coerce that `number` value to a `string` to print it out.

Then the statement `amount = "$" + String(amount)` *explicitly* coerces the `199.98` value to a `string` and adds a `"$"` character to the beginning. At this point, `amount` now holds the `string` value `"$199.98"`, so the second `console.log(..)` statement doesn't need to do any coercion to print it out.

JavaScript developers will note the flexibility of using the `amount` variable for each of the `99.99`, `199.98`, and the `"$199.98"` values. Static-typing enthusiasts would prefer a separate variable like `amountStr` to hold the final `"$199.98"` representation of the value, because it's a different type.

Either way, you'll note that `amount` holds a running value that changes over the course of the program, illustrating the primary purpose of variables: managing program *state*.

In other words, *state* is tracking the changes to values as your program runs.

Another common usage of variables is for centralizing value setting. This is more typically called *constants*, when you declare a variable with a value and intend for that value to *not change* throughout the program.

You declare these *constants*, often at the top of a program, so that it's convenient for you to have one place to go to alter a value if you need to. By convention, JavaScript variables as constants are usually capitalized, with underscores `_` between multiple words.

Here's a silly example:

```js
var TAX_RATE = 0.08;	// 8% sales tax

var amount = 99.99;

amount = amount * 2;

amount = amount + (amount * TAX_RATE);

console.log( amount );				// 215.9784
console.log( amount.toFixed( 2 ) );	// "215.98"
```

**Note:** Similar to how `console.log(..)` is a function `log(..)` accessed as an object property on the `console` value, `toFixed(..)` here is a function that can be accessed on `number` values. JavaScript `number`s aren't automatically formatted for dollars -- the engine doesn't know what your intent is and there's no type for currency. `toFixed(..)` lets us specify how many decimal places we'd like the `number` rounded to, and it produces the `string` as necessary.

The `TAX_RATE` variable is only *constant* by convention -- there's nothing special in this program that prevents it from being changed. But if the city raises the sales tax rate to 9%, we can still easily update our program by setting the `TAX_RATE` assigned value to `0.09` in one place, instead of finding many occurrences of the value `0.08` strewn throughout the program and updating all of them.

The newest version of JavaScript at the time of this writing (commonly called "ES6") includes a new way to declare *constants*, by using `const` instead of `var`:

```js
// as of ES6:
const TAX_RATE = 0.08;

var amount = 99.99;

// ..
```

Constants are useful just like variables with unchanged values, except that constants also prevent accidentally changing value somewhere else after the initial setting. If you tried to assign any different value to `TAX_RATE` after that first declaration, your program would reject the change (and in strict mode, fail with an error -- see "Strict Mode" in Chapter 2).

By the way, that kind of "protection" against mistakes is similar to the static-typing type enforcement, so you can see why static types in other languages can be attractive!

**Note:** For more information about how different values in variables can be used in your programs, see the *Types & Grammar* title of this series.

## Blocks （张润）

The phone store employee must go through a series of steps to complete the checkout as you buy your new phone.

Similarly, in code we often need to group a series of statements together, which we often call a *block*. In JavaScript, a block is defined by wrapping one or more statements inside a curly-brace pair `{ .. }`. Consider:

```js
var amount = 99.99;

// a general block
{
	amount = amount * 2;
	console.log( amount );	// 199.98
}
```

This kind of standalone `{ .. }` general block is valid, but isn't as commonly seen in JS programs. Typically, blocks are attached to some other control statement, such as an `if` statement (see "Conditionals") or a loop (see "Loops"). For example:

```js
var amount = 99.99;

// is amount big enough?
if (amount > 10) {			// <-- block attached to `if`
	amount = amount * 2;
	console.log( amount );	// 199.98
}
```

We'll explain `if` statements in the next section, but as you can see, the `{ .. }` block with its two statements is attached to `if (amount > 10)`; the statements inside the block will only be processed if the conditional passes.

**Note:** Unlike most other statements like `console.log(amount);`, a block statement does not need a semicolon (`;`) to conclude it.

## Conditionals （张润）

"Do you want to add on the extra screen protectors to your purchase, for $9.99?" The helpful phone store employee has asked you to make a decision. And you may need to first consult the current *state* of your wallet or bank account to answer that question. But obviously, this is just a simple "yes or no" question.

There are quite a few ways we can express *conditionals* (aka decisions) in our programs.

The most common one is the `if` statement. Essentially, you're saying, "*If* this condition is true, do the following...". For example:

```js
var bank_balance = 302.13;
var amount = 99.99;

if (amount < bank_balance) {
	console.log( "I want to buy this phone!" );
}
```

The `if` statement requires an expression in between the parentheses `( )` that can be treated as either `true` or `false`. In this program, we provided the expression `amount < bank_balance`, which indeed will either evaluate to `true` or `false` depending on the amount in the `bank_balance` variable.

You can even provide an alternative if the condition isn't true, called an `else` clause. Consider:

```js
const ACCESSORY_PRICE = 9.99;

var bank_balance = 302.13;
var amount = 99.99;

amount = amount * 2;

// can we afford the extra purchase?
if ( amount < bank_balance ) {
	console.log( "I'll take the accessory!" );
	amount = amount + ACCESSORY_PRICE;
}
// otherwise:
else {
	console.log( "No, thanks." );
}
```

Here, if `amount < bank_balance` is `true`, we'll print out `"I'll take the accessory!"` and add the `9.99` to our `amount` variable. Otherwise, the `else` clause says we'll just politely respond with `"No, thanks."` and leave `amount` unchanged.

As we discussed in "Values & Types" earlier, values that aren't already of an expected type are often coerced to that type. The `if` statement expects a `boolean`, but if you pass it something that's not already `boolean`, coercion will occur.

JavaScript defines a list of specific values that are considered "falsy" because when coerced to a `boolean`, they become `false` -- these include values like `0` and `""`. Any other value not on the "falsy" list is automatically "truthy" -- when coerced to a `boolean` they become `true`. Truthy values include things like `99.99` and `"free"`. See "Truthy & Falsy" in Chapter 2 for more information.

*Conditionals* exist in other forms besides the `if`. For example, the `switch` statement can be used as a shorthand for a series of `if..else` statements (see Chapter 2). Loops (see "Loops") use a *conditional* to determine if the loop should keep going or stop.

**Note:** For deeper information about the coercions that can occur implicitly in the test expressions of *conditionals*, see Chapter 4 of the *Types & Grammar* title of this series.

## 循环

在高峰时段，有很多排队等候与电话商店员工通话的顾客，虽然排队的人很多，但是她每次只需要服务好当前客户。
During busy times, there's a waiting list for customers who need to speak to the phone store employee. While there's still people on that list, she just needs to keep serving the next customer.

程序中的循环是指重复一组动作，直到某个条件失败的时候停止，换句话说，程序中的循环只有在条件成立时才会重复执行；循环可以采用不同的形式，但是他们必须满足这个基本行为。
Repeating a set of actions until a certain condition fails -- in other words, repeating only while the condition holds -- is the job of programming loops; loops can take different forms, but they all satisfy this basic behavior.

循环包括判断条件和循环体（通常为`{ .. }`）。每次条件成立时执行循环体，这就是常说的*迭代*。
A loop includes the test condition as well as a block (typically as `{ .. }`). Each time the loop block executes, that's called an *iteration*.

比如，`while`循环和`do..while`循环体现了循环体会在条件不再等于`true`时停止执行。
For example, the `while` loop and the `do..while` loop forms illustrate the concept of repeating a block of statements until a condition no longer evaluates to `true`:

```js
while (numOfCustomers > 0) {
	console.log( "How may I help you?" );

	// help the customer...

	numOfCustomers = numOfCustomers - 1;
}

// versus:

do {
	console.log( "How may I help you?" );

	// help the customer...

	numOfCustomers = numOfCustomers - 1;
} while (numOfCustomers > 0);
```

这2种循环唯一的区别是在第一次迭代之前（`while`）还是之后(`do..while`)进行条件判定。
The only practical difference between these loops is whether the conditional is tested before the first iteration (`while`) or after the first iteration (`do..while`).

在任一形式中，如果条件判定为`false`，下一次迭代将不再执行。这意味着如果初始判定条件为`false`，那么`while`循环将永远不会执行，但是`do..while`循环仅会执行第一次迭代。
In either form, if the conditional tests as `false`, the next iteration will not run. That means if the condition is initially `false`, a `while` loop will never run, but a `do..while` loop will run just the first time.

有时候你想要循环计算类似`0`到`9`这样的一组数字，你可以设置一个循环变量`i`，这个变量初始值为`0`,在每次迭代后自身加`1`。
Sometimes you are looping for the intended purpose of counting a certain set of numbers, like from `0` to `9` (ten numbers). You can do that by setting a loop iteration variable like `i` at value `0` and incrementing it by `1` each iteration.

**警告：** 以为一些历史原因，编程语言总是以`0`作为基准数字的形式计数，即以`0`为开始而不是`1`。如果你不熟悉这种思维模式，在初学阶段可能会感到很困惑，多花一些时间来练习从`0`开始计数，将使你在学习编程语言的时候变得更加从容。
**Warning:** For a variety of historical reasons, programming languages almost always count things in a zero-based fashion, meaning starting with `0` instead of `1`. If you're not familiar with that mode of thinking, it can be quite confusing at first. Take some time to practice counting starting with `0` to become more comfortable with it!

每次迭代的时候都会去测试判断条件是否成立，就好像在循环体中有一个隐含的`if`语句。
The conditional is tested on each iteration, much as if there is an implied `if` statement inside the loop.

我们可以通过JavaScript中的`break`语句来停止一次循环，此外，我们可以看到，没有断点机制非常容易出现死循环。
We can use JavaScript's `break` statement to stop a loop. Also, we can observe that it's awfully easy to create a loop that would otherwise run forever without a `break`ing mechanism.

让我们来说明一下：
Let's illustrate:

```js
var i = 0;

// a `while..true` loop would run forever, right?
while (true) {
	// stop the loop?
	if ((i <= 9) === false) {
		break;
	}

	console.log( i );
	i = i + 1;
}
// 0 1 2 3 4 5 6 7 8 9
```

**警告：** 这并不是一个好的实现循环的形式，这里仅仅为了说明上面的观点。
**Warning:** This is not necessarily a practical form you'd want to use for your loops. It's presented here for illustration purposes only.

虽然`while`（或`do..while`）可以实现上述要求，但还有另一个被称作`for`循环的形式可以达到项目的目的。
While a `while` (or `do..while`) can accomplish the task manually, there's another syntactic form called a `for` loop for just that purpose:

```js
for (var i = 0; i <= 9; i = i + 1) {
	console.log( i );
}
// 0 1 2 3 4 5 6 7 8 9
```

正如你所见，在这两种循环形式下，前10次循环（`i`从`0`到`9`）中，`i <= 9`的结果是`true`，但是当`i`的值是`10`时，`i <= 9`的结果是`false`。
As you can see, in both cases the conditional `i <= 9` is `true` for the first 10 iterations (`i` of values `0` through `9`) of either loop form, but becomes `false` once `i` is value `10`.

`for`循环有3条子语句：初始化语句(`var i=0`)，条件判断语句(`i <= 9`)，更新循环变量语句(`i = i + 1`)。所以
The `for` loop has three clauses: the initialization clause (`var i=0`), the conditional test clause (`i <= 9`), and the update clause (`i = i + 1`). So if you're going to do counting with your loop iterations, `for` is a more compact and often easier form to understand and write.

还有其他用来迭代特定值的循环形式，比如迭代对象的属性（见第二章），其中隐含的判断条件只是所有的属性是否都被处理。无论什么形式的循环，“直到条件失败才结束循环”的基本行为始终保持。
There are other specialized loop forms that are intended to iterate over specific values, such as the properties of an object (see Chapter 2) where the implied conditional test is just whether all the properties have been processed. The "loop until a condition fails" concept holds no matter what the form of the loop.

## 函数
## Functions

电话商店员工可能不会随身携带计算器来计算税金和最终购买金额。这是她需要定义一次并且重复使用的任务。奇怪的是，公司有一个内置这些功能的结账机器（电脑，平板电脑等）。
The phone store employee probably doesn't carry around a calculator to figure out the taxes and final purchase amount. That's a task she needs to define once and reuse over and over again. Odds are, the company has a checkout register (computer, tablet, etc.) with those "functions" built in.

同样的，你的程序肯定想要将代码的任务分解成可重用的部分，而不是重复的重复自己（双关意图）。定义一个`function`可以实现这个目的。
Similarly, your program will almost certainly want to break up the code's tasks into reusable pieces, instead of repeatedly repeating yourself repetitiously (pun intended!). The way to do this is to define a `function`.

函数通常是一个可以通过定义时命名的名称调用的代码段，其中的代码将在每次被调用时执行。考虑下面的代码：
A function is generally a named section of code that can be "called" by name, and the code inside it will be run each time. Consider:

```js
function printAmount() {
	console.log( amount.toFixed( 2 ) );
}

var amount = 99.99;

printAmount(); // "99.99"

amount = amount * 2;

printAmount(); // "199.98"
```

函数可以选择接受参数（aka参数）-- 你传递的值。同时也可以选择返回一个值。
Functions can optionally take arguments (aka parameters) -- values you pass in. And they can also optionally return a value back.

```js
function printAmount(amt) {
	console.log( amt.toFixed( 2 ) );
}

function formatAmount() {
	return "$" + amount.toFixed( 2 );
}

var amount = 99.99;

printAmount( amount * 2 );		// "199.98"

amount = formatAmount();
console.log( amount );			// "$99.99"
```

`printAmount(..)`函数接受一个被称作`amt`的参数，`formatAmount()`函数返回一个值。当然，你可以在同一个函数里组合这2个方法。
The function `printAmount(..)` takes a parameter that we call `amt`. The function `formatAmount()` returns a value. Of course, you can also combine those two techniques in the same function.

函数常常被用来封装想要多次调用的代码，但他们也可用于将相关联的代码部分封装在一个被命名的集合中，即使你只打算调用一次。
Functions are often used for code that you plan to call multiple times, but they can also be useful just to organize related bits of code into named collections, even if you only plan to call them once.

考虑下面的代码：
Consider:

```js
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
	// calculate the new amount with the tax
	amt = amt + (amt * TAX_RATE);

	// return the new amount
	return amt;
}

var amount = 99.99;

amount = calculateFinalPurchaseAmount( amount );

console.log( amount.toFixed( 2 ) );		// "107.99"
```

虽然`calculateFinalPurchaseAmount(..)`只被调用了一次，但是通过将他的逻辑（`amount = calculateFinal...`语句）封装成一个单独的命名函数，使得代码更容易被阅读。如果函数中包含更多的语句，其好处将更加明显。
Although `calculateFinalPurchaseAmount(..)` is only called once, organizing its behavior into a separate named function makes the code that uses its logic (the `amount = calculateFinal...` statement) cleaner. If the function had more statements in it, the benefits would be even more pronounced.

## 作用域
### Scope

如果你想购买一款手机专卖店里没有的型号的手机，她是无法卖给你的，她只能在商店所提供的手机型号中售卖。如果你想购买你所需的手机型号，那你必须去别的商店里找找了。
If you ask the phone store employee for a phone model that her store doesn't carry, she will not be able to sell you the phone you want. She only has access to the phones in her store's inventory. You'll have to try another store to see if you can find the phone you're looking for.

编程中对这个概念有一个术语：*作用域*（技术上称为词法作用域）。在JavaScript中，每个函数拥有自己的独立作用域。作用域是一个包含如何按变量名称访问规则的变量集合。只有在该函数内部的代码可以访问该函数限定的变量作用域
Programming has a term for this concept: *scope* (technically called *lexical scope*). In JavaScript, each function gets its own scope. Scope is basically a collection of variables as well as the rules for how those variables are accessed by name. Only code inside that function can access that function's *scoped* variables.

一个变量名称在同一个作用域内必须是唯一的 -- 不能有2个不同的`a`变量在同一作用域内，但是同样的变量名称`a`可以出现在不同作用域内。
A variable name has to be unique within the same scope -- there can't be two different `a` variables sitting right next to each other. But the same variable name `a` could appear in different scopes.

```js
function one() {
	// this `a` only belongs to the `one()` function
	var a = 1;
	console.log( a );
}

function two() {
	// this `a` only belongs to the `two()` function
	var a = 2;
	console.log( a );
}

one();		// 1
two();		// 2
```

另外，一个作用域可以嵌套在另一个作用域内，就想生日聚会上的小丑吹一个套在另一个气球里的气球一样。如果一个作用域嵌套在另一个作用域内，则最内层作用域的代码可以访问任一作用域内的变量。
Also, a scope can be nested inside another scope, just like if a clown at a birthday party blows up one balloon inside another balloon. If one scope is nested inside another, code inside the innermost scope can access variables from either scope.

考虑下面的代码：
Consider:

```js
function outer() {
	var a = 1;

	function inner() {
		var b = 2;

		// we can access both `a` and `b` here
		console.log( a + b );	// 3
	}

	inner();

	// we can only access `a` here
	console.log( a );			// 1
}

outer();
```

词法作用域规则定义，一个作用域中的变量可以访问该作用域范围或其外部作用域范围的任意变量。
Lexical scope rules say that code in one scope can access variables of either that scope or any scope outside of it.

所以，`inner()`函数中的代码可以同时访问变量`a`和变量`b`，但是`outer()`函数只能访问变量`a`，不能访问变量`b`的原因是变量`b`只存在于`inner()`函数的作用域中。
So, code inside the `inner()` function has access to both variables `a` and `b`, but code in `outer()` has access only to `a` -- it cannot access `b` because that variable is only inside `inner()`.

回想之前的代码片段：
Recall this code snippet from earlier:

```js
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
	// calculate the new amount with the tax
	amt = amt + (amt * TAX_RATE);

	// return the new amount
	return amt;
}
```

因为词法作用域。我们可以在`calculateFinalPurchaseAmount(..)`函数内部访问`TAX_RATE`常量(变量)，即使我们并没有把它当做参数传递进去。
The `TAX_RATE` constant (variable) is accessible from inside the `calculateFinalPurchaseAmount(..)` function, even though we didn't pass it in, because of lexical scope.

**注意：**有关更多词法作用域的信息，请参阅本系列*作用域和闭包*的前三个章节
**Note:** For more information about lexical scope, see the first three chapters of the *Scope & Closures* title of this series.

## 练习
## Practice

在学习编程的过程中，实践是不可或缺的。在你变成一个程序员的过程中
There is absolutely no substitute for practice in learning programming. No amount of articulate writing on my part is alone going to make you a programmer.

考虑到这一点，让我们尝试练习本章中所学到的一些概念。我会给出“需求”，你先独自尝试。然后可以参考下面的代码列表看看我是如何实现它的。
With that in mind, let's try practicing some of the concepts we learned here in this chapter. I'll give the "requirements," and you try it first. Then consult the code listing below to see how I approached it.

* 编写一个程序用来计算你购买手机的总价。你会不断购买手机（提示：循环！）直到你花光你银行账户里的所有资金。只要你的购买金额低于你的精神消费阈值，你还会为每一个手机购买相应的配件。
* Write a program to calculate the total price of your phone purchase. You will keep purchasing phones (hint: loop!) until you run out of money in your bank account. You'll also buy accessories for each phone as long as your purchase amount is below your mental spending threshold.

* 在计算完你的购买金额后，加入纳税金额，然后打印出格式正确的经过计算的购买金额
* After you've calculated your purchase amount, add in the tax, then print out the calculated purchase amount, properly formatted.

* 最终，检查你的银行账户余额，看是否负担得起。
* Finally, check the amount against your bank account balance to see if you can afford it or not.

* 你应当为“税率”，“手机单价”，“配件单价”和“支出上限”设置一些常量，并为你的“银行账户余额”设置一个变量。
* You should set up some constants for the "tax rate," "phone price," "accessory price," and "spending threshold," as well as a variable for your "bank account balance.""

* 你应当定义一个用来计算税金和把价格变为四舍五入保留两位小数并且带“$”前缀格式的函数
* You should define functions for calculating the tax and for formatting the price with a "$" and rounding to two decimal places.
* **奖励挑战：**尝试将输入合并到此程序中，或许在输入前还可以增加“提示”功能。例如，你可以提示用户的银行账户余额。让它变的更有创造性和趣味
* **Bonus Challenge:** Try to incorporate input into this program, perhaps with the `prompt(..)` covered in "Input" earlier. You may prompt the user for their bank account balance, for example. Have fun and be creative!

好的，继续尝试完成它。在你完成自己的程序前不要偷看我的代码。
OK, go ahead. Try it. Don't peek at my code listing until you've given it a shot yourself!

**注意：** 因为这是一本关于JavaScript的书，很明显我会用JavaScript语言去完成练习。但是你可以用任一一种你熟悉的编程语言来实现它。
**Note:** Because this is a JavaScript book, I'm obviously going to solve the practice exercise in JavaScript. But you can do it in another language for now if you feel more comfortable.

这是我解决这个练习的JavaScript方案
Here's my JavaScript solution for this exercise:

```js
const SPENDING_THRESHOLD = 200;
const TAX_RATE = 0.08;
const PHONE_PRICE = 99.99;
const ACCESSORY_PRICE = 9.99;

var bank_balance = 303.91;
var amount = 0;

function calculateTax(amount) {
	return amount * TAX_RATE;
}

function formatAmount(amount) {
	return "$" + amount.toFixed( 2 );
}

// keep buying phones while you still have money
while (amount < bank_balance) {
	// buy a new phone!
	amount = amount + PHONE_PRICE;

	// can we afford the accessory?
	if (amount < SPENDING_THRESHOLD) {
		amount = amount + ACCESSORY_PRICE;
	}
}

// don't forget to pay the government, too
amount = amount + calculateTax( amount );

console.log(
	"Your purchase: " + formatAmount( amount )
);
// Your purchase: $334.76

// can you actually afford this purchase?
if (amount > bank_balance) {
	console.log(
		"You can't afford this purchase. :("
	);
}
// You can't afford this purchase. :(
```

**注意：** 运行此JavaScript程序最简单的方法是将其输入到你默认浏览器的控制台中。
**Note:** The simplest way to run this JavaScript program is to type it into the developer console of your nearest browser.

你怎么实现的？阅读到这里，你已经看到我的实现代码。你可以再次尝试，并通过改变一些常量来观察程序运行后再不同的值下的运行结果。
How did you do? It wouldn't hurt to try it again now that you've seen my code. And play around with changing some of the constants to see how the program runs with different values.

## 复习
## Review

学习编程并不是一个复杂和压制性的过程。你仅仅需要把一些基本概念武装在你的脑海里。
Learning programming doesn't have to be a complex and overwhelming process. There are just a few basic concepts you need to wrap your head around.

这些行为就像搭建积木。 如果你想要搭建一座高塔，那你需要不断往上垒砖块。编程也一样。这里有一些用来编程的基本模块
These act like building blocks. To build a tall tower, you start first by putting block on top of block on top of block. The same goes with programming. Here are some of the essential programming building blocks:

* 你需要*运算符*来对值进行操作
* You need *operators* to perform actions on values.

* 你需要值和*类型*来执行不同类型的操作，比如用`number`类型做数学运算，用`string`类型输出。
* You need values and *types* to perform different kinds of actions like math on `number`s or output with `string`s.
* 在程序执行期间，你需要*变量*来存储数据（aka *状态*）
* You need *variables* to store data (aka *state*) during your program's execution.

* 在`if`语句中，你需要根据*条件*来决定做什么。
* You need *conditionals* like `if` statements to make decisions.*

* 你需要*循环*来重复执行任务，直到停止条件变为true。
* You need *loops* to repeat tasks until a condition stops being true.* *

* 你需要通过*函数*来把你的代码和逻辑组织在一起形成一个可重用的代码块。
* You need *functions* to organize your code into logical and reusable chunks.* * *

代码注释是编写更容易阅读的代码的有效方式，它可以使得你的程序在遇到问题时变得更容易理解，维护和修复。
Code comments are one effective way to write more readable code, which makes your program easier to understand, maintain, and fix later if there are problems.

最终，不要忽视时间的力量。学习如何编写代码的最好方式就是不断写代码。
Finally, don't neglect the power of practice. The best way to learn how to write code is to write code.

我很高兴你现在正在学习如何编写代码！继续努力吧，不要忘记查阅其他初学者编程资源（书，博客，在线教程等）。这章和这本书是一个很好的开始，但他们只是一个简单的介绍。
I'm excited you're well on your way to learning how to code, now! Keep it up. Don't forget to check out other beginner programming resources (books, blogs, online training, etc.). This chapter and this book are a great start, but they're just a brief introduction.

下一张会从更具体的JavaScript视角回顾本章提到的许多概念，将突出本系列其余部分中更深入的主题。
The next chapter will review many of the concepts from this chapter, but from a more JavaScript-specific perspective, which will highlight most of the major topics that are addressed in deeper detail throughout the rest of the series.
