# 你不知道的JS（You Don't Know JS: Up & Going）
# 第二章：进入JavaScript（Chapter 2: Into JavaScript）

In the previous chapter, I introduced the basic building blocks of programming, such as variables, loops, conditionals, and functions. Of course, all the code shown has been in JavaScript. But in this chapter, we want to focus specifically on things you need to know about JavaScript to get up and going as a JS developer.    
在上一章中，我介绍了编程的基本代码块，如变量、循环、条件和函数。当然，所有的代码都用JavaScript编写。但在本章中，我们会专门关注作为一个JS开发人员你需要了解的关于JavaScript的事情。

We will introduce quite a few concepts in this chapter that will not be fully explored until subsequent *YDKJS* books. You can think of this chapter as an overview of the topics covered in detail throughout the rest of this series.    
我们将在本章中介绍相当多的概念，直到随后的*YDKJS*书籍才会被完全探索。您可以将本章视为本系列其余部分的概述。

Especially if you're new to JavaScript, you should expect to spend quite a bit of time reviewing the concepts and code examples here multiple times. Any good foundation is laid brick by brick, so don't expect that you'll immediately understand it all the first pass through.    
特别是如果你是JavaScript的新手，你应该花费更多的时间在这里多次理解概念和代码示例。任何良好的基础都是累积出来的，所以不要指望你能马上学会。

Your journey to deeply learn JavaScript starts here.    
深入地理解学习JavaScript从这里开始。    

**Note:** As I said in Chapter 1, you should definitely try all this code yourself as you read and work through this chapter. Be aware that some of the code here assumes capabilities introduced in the newest version of JavaScript at the time of this writing (commonly referred to as "ES6" for the 6th edition of ECMAScript -- the official name of the JS specification). If you happen to be using an older, pre-ES6 browser, the code may not work. A recent update of a modern browser (like Chrome, Firefox, or IE) should be used.    
**注意:** 正如我在第1章中所说，你应该在阅读和完成本章时自己尝试所有这些代码。请注意，有些代码使用了最新版本的JavaScript中的功能（一般指第6版的ECMAScript--JS规范的官方名称，通常称为“ES6”）。如果你碰巧使用一个旧的不支持ES6的浏览器，代码可能不能执行。应使用最新的现代浏览器（如Chrome，Firefox或IE）

## Values & Types(值与类型) --罗尧

As we asserted in Chapter 1, JavaScript has typed values, not typed variables. The following built-in types are available:
正如我们在第1章中声明的，JavaScript数据有类型，变量没有。 它提供以下几种内置类型：

* `string`
* `number`
* `boolean`
* `null` and `undefined`
* `object`
* `symbol` (new to ES6)

JavaScript provides a `typeof` operator that can examine a value and tell you what type it is:
JavaScript提供了一个`typeof`运算符，可以检查值并告诉您它是什么类型：

```js
var a;
typeof a;				// "undefined"

a = "hello world";
typeof a;				// "string"

a = 42;
typeof a;				// "number"

a = true;
typeof a;				// "boolean"

a = null;
typeof a;				// "object" -- weird, bug

a = undefined;
typeof a;				// "undefined"

a = { b: "c" };
typeof a;				// "object"
```

The return value from the `typeof` operator is always one of six (seven as of ES6! - the "symbol" type) string values. That is, `typeof "abc"` returns `"string"`, not `string`.
`typeof`运算符的返回值总是六个（ES6中是七个 - 多了“symbol”类型）字符串中的一个。 也就是说，`typeof "abc"`返回`"string"`，而不是`string`。

Notice how in this snippet the `a` variable holds every different type of value, and that despite appearances, `typeof a` is not asking for the "type of `a`", but rather for the "type of the value currently in `a`." Only values have types in JavaScript; variables are just simple containers for those values.
注意在段代码中，`a`变量保存每个不同类型的值，并且尽管表象如此，`typeof a`不是问“a的类型”，而是为了问“存在`a`中的值的类型”。在JavaScript中只有值才有类型，变量只是这些值的简单容器。

`typeof null` is an interesting case, because it errantly returns `"object"`, when you'd expect it to return `"null"`.
`typeof null`是一个有趣的案例，当你期望它返回`"null"`时它将错误地返回`"object"`。

**Warning:** This is a long-standing bug in JS, but one that is likely never going to be fixed. Too much code on the Web relies on the bug and thus fixing it would cause a lot more bugs!
**警告：**这是JS中一个长期存在的错误，但是可能永远不会被修复。Web上的代码太多依赖于错误，因此修复它会导致更多的错误！

Also, note `a = undefined`. We're explicitly setting `a` to the `undefined` value, but that is behaviorally no different from a variable that has no value set yet, like with the `var a;` line at the top of the snippet. A variable can get to this "undefined" value state in several different ways, including functions that return no values and usage of the `void` operator.
另外，注意 `a = undefined`。我们显式地将`a`设置为`undefined`值，但是这与没有设置值的变量没有什么不同，就像在代码片段顶部的`var a;`。变量可以以几种不同的方式获得这个"undefined"值状态，包括不返回任何值的函数和使用`void`运算符。

### 对象(Objects) --罗尧

The `object` type refers to a compound value where you can set properties (named locations) that each hold their own values of any type. This is perhaps one of the most useful value types in all of JavaScript.
`object`类型是一个复合值，您可以在其中设置属性（命名位置），属性可以是任意类型的值。这可能是JavaScript中最有用的值类型之一。

```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};

obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```

It may be helpful to think of this `obj` value visually:
这样看有助于理解`obj`值

<img src="./images/chapter2/fig4.png">

Properties can either be accessed with *dot notation* (i.e., `obj.a`) or *bracket notation* (i.e., `obj["a"]`). Dot notation is shorter and generally easier to read, and is thus preferred when possible.
属性可以用*点符号*（即`obj.a`）或*括号符号*（即`obj[“a”]`）访问。点符号更短，通常更容易阅读，因此可以的话尽量使用点符号。

Bracket notation is useful if you have a property name that has special characters in it, like `obj["hello world!"]` -- such properties are often referred to as *keys* when accessed via bracket notation. The `[ ]` notation requires either a variable (explained next) or a `string` *literal* (which needs to be wrapped in `" .. "` or `' .. '`).
如果你有一个有特殊字符的属性名，如`obj["hello world!"]`-- 括号符号是有用的。当通过括号符号访问时，这样的属性通常被称为*keys*。`[]`符号里是一个变量（下面解释）或一个`string` *字面量*（需要被包裹在`" .. "`或 `' .. '`）。

Of course, bracket notation is also useful if you want to access a property/key but the name is stored in another variable, such as:
当然，如果要访问属性/键，但是名称存储在另一个变量中，括号符号很有用，例如：

```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```

**Note:** For more information on JavaScript `object`s, see the *this & Object Prototypes* title of this series, specifically Chapter 3.
**注意：**有关JavaScript对象的更多信息，请参阅本系列的 *this & Object Prototypes*标题，特别是第3章。

There are a couple of other value types that you will commonly interact with in JavaScript programs: *array* and *function*. But rather than being proper built-in types, these should be thought of more like subtypes -- specialized versions of the `object` type.
JavaScript中还有其他的值类型，比如：*array*和*function*。对比内置类型，它们更像是对象类型的有专门功能的子类型。

#### 数组(Arrays)

An array is an `object` that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions. For example:
数组属于`object`，它有值（任意类型），但是不是在属性/键中而是数字索引位置。例如:

```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```

**Note:** Languages that start counting at zero, like JS does, use `0` as the index of the first element in the array.
*注：*计算机语言一般从零开始计数，像是JS，使用`0`作为数组的第一个元素的索引。

It may be helpful to think of `arr` visually:
这样看有助于理解`arr`

![](image/fig5.png)
<img src="./images/chapter2/fig5.png">

Because arrays are special objects (as `typeof` implies), they can also have properties, including the automatically updated `length` property.
由于数组是一种特殊的对象（如`typeof`所得），他们也可以有属性，包括自动更新的`length`属性。

You theoretically could use an array as a normal object with your own named properties, or you could use an `object` but only give it numeric properties (`0`, `1`, etc.) similar to an array. However, this would generally be considered improper usage of the respective types.
理论上你可以用一个数组作为你自己命名属性的普通对象，或者你可以使用一个`object`，但只给它类似数组的数字属性(`0`, `1`, 等等）。但是并不推荐。

The best and most natural approach is to use arrays for numerically positioned values and use `object`s for named properties.
最好的方法还是数组使用下标，对象使用命名属性。

#### 函数(Functions) --罗尧

The other `object` subtype you'll use all over your JS programs is a function:
另一个在JS中经常用到的`object`类型就是函数

```js
function foo() {
	return 42;
}

foo.bar = "hello world";

typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"
```

Again, functions are a subtype of `objects` -- `typeof` returns `"function"`, which implies that a `function` is a main type -- and can thus have properties, but you typically will only use function object properties (like `foo.bar`) in limited cases.
同样，函数是`objects`的子类型，因此可以有属性。`typeof`返回`"function"`，这意味着一个`function`是一个主要的类型，但是你很少会用到函数对象属性 （如`foo.bar`）。

**Note:** For more information on JS values and their types, see the first two chapters of the *Types & Grammar* title of this series.
**注：**有关JS值及其类型的更多信息，请参阅本系列的*Types & Grammar*标题的前两个章节。

### 内置类型方法(Built-In Type Methods) --张静

The built-in types and subtypes we've just discussed have behaviors exposed as properties and methods that are quite
powerful and useful.
我们刚刚讨论的这种内置类型具有非常强大的暴露在外的属性和方法。

For example:
例如：

```js
var a = "hello world";
var b = 3.14159;

a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"
```

The "how" behind being able to call `a.toUpperCase()` is more complicated than just that method existing on the value.
比起如何能调用a.toUpperCase()比让这个方法有值更重要。

Briefly, there is a `String` (capital `S`) object wrapper form, typically called a "native," that pairs with the primitive `string` type; it's this object wrapper that defines the `toUpperCase()` method on its prototype.
简要地说，这是一个字符串（首字母“S”）对象包装形式，通常称为”本地“，与原始的字符串类型配对；它这是定义这个`toUpperCase()`方法在原型上的对象包装。

When you use a primitive value like `"hello world"` as an `object` by referencing a property or method (e.g., `a.toUpperCase()` in the previous snippet), JS automatically "boxes" the value to its object wrapper counterpart (hidden under the covers).
当你使用一个像“hello world”的原始值作为一个对象，通过参考一个在以前片段中的属性或方法如`a.toUpperCase()`，JS自动“盒子”的值到其对象包装对应（隐藏在封面下）。

A `string` value can be wrapped by a `String` object, a `number` can be wrapped by a `Number` object, and a `boolean` can be
wrapped by a `Boolean` object. For the most part, you don't need to worry about or directly use these object wrapper forms of the values -- prefer the primitive value forms in practically all cases and JavaScript will take care of the rest for you.
（take care of翻译为处理）
一个字符串对象能够包装一个字符串值，一个Number对象能够包装一个数字，一个boolean对象能够包装一个布尔值。在大多数情况下，你不需要担心或直接使用这些对象包装器的形式的值 －－如果几乎所有的情况下都喜欢原始值形式，javascript将会替你处理剩余的部分。

**Note:** For more information on JS natives and "boxing," see Chapter 3 of the *Types & Grammar* title of this series. To better understand the prototype of an object, see Chapter 5 of the *this & Object Prototypes* title of this series.
**注意：** 有关JS本地和“boxing”的更多信息，请看本系列*Types＆Grammar*标题的第3章。为了更好的理解对象的原型，请看本系列的*this＆Object Prototypes*标题的第5章。

### 比较值(Comparing Values)

There are two main types of value comparison that you will need to make in your JS programs: *equality* and *inequality*.
这儿有两种主要类型的值的比较，你需要放入你的JS程序：*相等* 和 *不等*。

The result of any comparison is a strictly `boolean` value (`true` or `false`), regardless of what value types are compared.
不管什么类型的值，比较的结果是一个布尔值(`true` or `false`)，

#### 强迫(Coercion)

We talked briefly about coercion in Chapter 1, but let's revisit it here.
我们在第1章中简要地讨论了强制，但让我们在这里重温一下。

Coercion comes in two forms in JavaScript: *explicit* and *implicit*. Explicit coercion is simply that you can see obviously from the code that a conversion from one type to another will occur, whereas implicit coercion is when the type conversion can happen as more of a non-obvious side effect of some other operation.
强制在JavaScript中有两种形式：*explicit* 和 *implicit*。显式强制只是你可以从代码中明显的看到从一种类型到另一种类型的转换将发生，而隐式强制是当类型转换时可能发生更多的一些其他操作的非显而易见的副作用。

You've probably heard sentiments like "coercion is evil" drawn from the fact that there are clearly places where coercion can produce some surprising results. Perhaps nothing evokes frustration from developers more than when the language surprises them.
你可能已经听到了诸如“强制是邪恶”的情绪，这是因为有明显的地方，强制可以产生一些令人惊讶的结果。也许没有什么能让开发人员比起语言更能感到挫折的了。

Coercion is not evil, nor does it have to be surprising. In fact, the majority of cases you can construct with type coercion are quite sensible and understandable, and can even be used to *improve* the readability of your code. But we won't go much further into that debate -- Chapter 4 of the *Types & Grammar* title of this series covers all sides.
强制不是邪恶的，也不必惊讶。事实上，大多数情况下，你可以用类型强制构造是相当明智和可理解的，甚至可以用于提高代码的可读性。我们不会进一步讨论这场辩论－－本系列的* Types＆Grammar *标题的第4章涵盖所有方面。

Here's an example of *explicit* coercion:

```js
var a = "42";

var b = Number( a );

a;				// "42"
b;				// 42 -- the number!
```

And here's an example of *implicit* coercion:

```js
var a = "42";

var b = a * 1;	// "42" implicitly coerced to 42 here

a;				// "42"
b;				// 42 -- the number!
```

#### 真理与错误(Truthy & Falsy)

In Chapter 1, we briefly mentioned the "truthy" and "falsy" nature of values: when a non-`boolean` value is coerced to a`boolean`, does it become `true` or `false`, respectively?
在第1章中，我们简要提到了值的“真实”和“伪”性质：当一个非布尔值被强制转换为一个布尔值时，它分别成为“真”或“假”吗？

The specific list of "falsy" values in JavaScript is as follows:
JavaScript中的“falsy”值的具体列表如下：

* `""` (empty string)
* `0`, `-0`, `NaN` (invalid `number`)
* `null`, `undefined`
* `false`

Any value that's not on this "falsy" list is "truthy." Here are some examples of those:
任何不在这个“falsy”列表上的值是“真实的”。这里有一些例子：

* `"hello"`
* `42`
* `true`
* `[ ]`, `[ 1, "2", 3 ]` (arrays)
* `{ }`, `{ a: 42 }` (objects)
* `function foo() { .. }` (functions)

It's important to remember that a non-`boolean` value only follows this "truthy"/"falsy" coercion if it's actually coerced to a `boolean`. It's not all that difficult to confuse yourself with a situation that seems like it's coercing a value to a `boolean` when it's not.
重要的是要记住，一个非`boolean`值只有遵循这个“真实”/“falsy”强制，如果它实际上强制为一个“布尔”。这不是所有的困难，混淆自己的情况，似乎它的强迫一个值到一个“布尔”，而不是。

#### 相等(Equality)

There are four equality operators: `==`, `===`, `!=`, and `!==`. The `!` forms are of course the symmetric "not equal" versions of their counterparts; *non-equality* should not be confused with *inequality*.
这儿有四个等于的操作：`==`，`===`，`!=`，和`!==`。`！`对应不等。不全等不应该与不等混淆。

The difference between `==` and `===` is usually characterized that `==` checks for value equality and `===` checks for both value and type equality. However, this is inaccurate. The proper way to characterize them is that `==` checks for value equality with coercion allowed, and `===` checks for value equality without allowing coercion; `===` is often called "strict equality" for this reason.
`==`和`===`的不同是，通常`==`代表值等，而`===`代表值和类型都等。然而，这是不准确的。用正确的方法去描述它们是`==`强制允许验证值等，而`===`不允许强制验证值等。这就是`===`通常被称为严格相等的理由。

Consider the implicit coercion that's allowed by the `==` loose-equality comparison and not allowed with the `===` strict-equality:


```js
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```

In the `a == b` comparison, JS notices that the types do not match, so it goes through an ordered series of steps to coerce one or both values to a different type until the types match, where then a simple value equality can be checked.
在`a == b`比较中，JS注意到类型不匹配，所以它通过有序的一系列步骤来强制一个或两个值到不同的类型，直到类型匹配，然后一个简单的值相等检查。

If you think about it, there's two possible ways `a == b` could give `true` via coercion. Either the comparison could end up as `42 == 42` or it could be `"42" == "42"`. So which is it?
如果你想到它，有两种可能的方式`a == b`可以通过强制给予`true`。比较可能最终为`"42" == "42"`，也可以是`"42"=="42"`。那是什么呢？

The answer: `"42"` becomes `42`, to make the comparison `42 == 42`. In such a simple example, it doesn't really seem to matter which way that process goes, as the end result is the same. There are more complex cases where it matters not just what the end result of the comparison is, but *how* you get there.
答案：`"42"`变成了`42`，通过比较`42 == 42`。在这个例子中，过程似乎不重要，因为结果是一样的。有更复杂的情况，重要的不仅是比较的最终结果，而是你*如何*到那里。

The `a === b` produces `false`, because the coercion is not allowed, so the simple value comparison obviously fails. Many developers feel that `===` is more predictable, so they advocate always using that form and staying away from `==`. I think this view is very shortsighted. I believe `==` is a powerful tool that helps your program, *if you take the time to learn how it works.*
`a === b`产生`false`，因为强制是不允许的，所以简单的值比较显然失败了。许多开发人员认为`===`是更可预测的，因此他们主张始终使用该形式并远离`==`。我认为这个观点很短视。我相信`==`是一个强大的工具，可以帮助你的程序，*如果你花时间来了解它是如何工作的。

We're not going to cover all the nitty-gritty details of how the coercion in `==` comparisons works here. Much of it is pretty sensible, but there are some important corner cases to be careful of. You can read section 11.9.3 of the ES5 specification (http://www.ecma-international.org/ecma-262/5.1/) to see the exact rules, and you'll be surprised at just how straightforward this mechanism is, compared to all the negative hype surrounding it.
我们不会涵盖所有关于`==`比较中的强制如何在这里工作的细节细节。大部分是相当明智的，但有一些重要的角落要小心。您可以阅读ES5规范 (http://www.ecma-international.org/ecma-262/5.1/) 的第11.9.3节以查看确切的规则，你会惊讶于这种机制是多么简单，相比之下所有的负面炒作。

To boil down a whole lot of details to a few simple takeaways, and help you know whether to use `==` or `===` in various situations, here are my simple rules:
把很多细节归纳为几个简单的介绍，帮助你知道在各种情况下是使用`==`还是`===`，这里是我简单的规则：

* If either value (aka side) in a comparison could be the `true` or `false` value, avoid `==` and use `===`.
* 如果比较中的任一值（aka side）可以是`true`或`false`值，请避免`==`和使用`===`。
* If either value in a comparison could be of these specific values (`0`, `""`, or `[]` -- empty array), avoid `==` and use `===`.
* 如果比较中的任一值可以是这些特定值（`0`，`“”`或`[]` - 空数组），避免`==`和使用`===`。
* In *all* other cases, you're safe to use `==`. Not only is it safe, but in many cases it simplifies your code in a way that improves readability.
* 在*所有*其他情况下，你可以安全地使用`==`。它不仅安全，而且在许多情况下，它以提高可读性的方式简化了代码。

What these rules boil down to is requiring you to think critically about your code and about what kinds of values can come through variables that get compared for equality. If you can be certain about the values, and `==` is safe, use it! If you can't be certain about the values, use `===`. It's that simple.
这些规则要求你仔细思考你的代码，以及什么样的值可以通过比较相等的变量。如果你可以确定的值，和`==`是安全的，使用它！如果你不能确定的值，使用`===`。就是这么简单。

The `!=` non-equality form pairs with `==`, and the `!==` form pairs with `===`. All the rules and observations we just discussed hold symmetrically for these non-equality comparisons.
`！=`非等式形式与`==`形成对，`！==`形式与`===`形成对。我们刚刚讨论的所有规则和观察对称地保持这些不等式比较。

You should take special note of the `==` and `===` comparison rules if you're comparing two non-primitive values, like `object`s (including `function` and `array`). Because those values are actually held by reference, both `==` and `===` comparisons will simply check whether the references match, not anything about the underlying values.
如果你比较两个非原始值，你应该特别注意`==`和`===`比较规则，像`object`s（包括`function`和`array`）。因为这些值实际上是通过引用来保存的，`==`和`===`比较只是检查引用是否匹配，而不是关于底层值。

For example, `array`s are by default coerced to `string`s by simply joining all the values with commas (`,`) in between. You might think that two `array`s with the same contents would be `==` equal, but they're not:
例如，`array`s在默认情况下通过用逗号（`，`）连接所有的值强制为`string`s。你可能会认为两个具有相同内容的数组是`==`等于，但是它们不是：

```js
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;		// true
b == c;		// true
a == b;		// false
```

**Note:** For more information about the `==` equality comparison rules, see the ES5 specification (section 11.9.3) and also consult Chapter 4 of the *Types & Grammar* title of this series; see Chapter 2 for more information about values versus references.
**注意：**有关`==`等式比较规则的更多信息，请参阅ES5规范（第11.9.3节），并参阅本系列的* Types＆Grammar *标题的第4章;有关值与引用的更多信息，请参阅第2章。

#### 不等式(Inequality) --张静
####

The `<`, `>`, `<=`, and `>=` operators are used for inequality, referred to in the specification as "relational comparison." Typically they will be used with ordinally comparable values like `number`s. It's easy to understand that `3 < 4`.
`<`，`>`，`<=`和`> =`运算符用于不等式，在规范中称为”关系比较“。通常，它们将与诸如`number`s之类的可比较值一起使用。很容易理解`3 <4`。

But JavaScript `string` values can also be compared for inequality, using typical alphabetic rules (`"bar" < "foo"`).
但是JavaScript'string'值也可以使用典型的字母规则（`"bar" < "foo"`）来比较不等式。

What about coercion? Similar rules as `==` comparison (though not exactly identical!) apply to the inequality operators. Notably, there are no "strict inequality" operators that would disallow coercion the same way `===` "strict equality" does.
强制怎么办？类似的规则如`==`比较（虽然不完全相同！）适用于不等式运算符。值得注意的是，没有“严格不等式”运算符不允许强制使用`===`“严格相等”的方式。

Consider:
思考：

```js
var a = 41;
var b = "42";
var c = "43";

a < b;		// true
b < c;		// true
```

What happens here? In section 11.8.5 of the ES5 specification, it says that if both values in the `<` comparison are `string`s, as it is with `b < c`, the comparison is made lexicographically (aka alphabetically like a dictionary). But if one or both is not a `string`, as it is with `a < b`, then both values are coerced to be `number`s, and a typical numeric comparison occurs.
这里发生了什么？在ES5规范的第11.8.5节中，它说如果`<`比较中的两个值都是`string`s，因为它和`b <c`一样，比较是按字典顺序进行的（像字典一样）。但是如果一个或两个不是一个`字符串`，因为它与`a<b`，那么两个值都被强制为`数字`，并且发生典型的数字比较。

The biggest gotcha you may run into here with comparisons between potentially different value types -- remember, there are no "strict inequality" forms to use -- is when one of the values cannot be made into a valid number, such as:
最大的问题是你可能会遇到潜在不同的值类型之间的比较 - 记住，没有“严格不等式”形式可以使用 - 是当一个值不能被变成一个有效的数字，例如：

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

Wait, how can all three of those comparisons be `false`? Because the `b` value is being coerced to the "invalid number value" `NaN` in the `<` and `>` comparisons, and the specification says that `NaN` is neither greater-than nor less-than any other value.
等等，这三个比较怎么都是假的？因为`b`值在`<`和`>`比较中被强制转换为“无效数值”`NaN`，并且规范说`NaN`既不大于也不小于任何其他值。

The `==` comparison fails for a different reason. `a == b` could fail if it's interpreted either as `42 == NaN` or `"42" == "foo"` -- as we explained earlier, the former is the case.
`==`比较失败的原因不同。 `a == b`可能会失败，如果它被解释为`42 == NaN`或`"42"=="foo"` -- 正如我们前面解释的，前者是这种情况。

**Note:** For more information about the inequality comparison rules, see section 11.8.5 of the ES5 specification and also consult Chapter 4 of the *Types & Grammar* title of this series.
**注意：** 有关不等式比较规则的更多信息，请参阅ES5规范的第11.8.5节，并参阅本系列的*Types＆Grammar*标题的第4章。

## 变量(Variables) --翠翠

In JavaScript, variable names (including function names) must be valid *identifiers*. The strict and complete rules for valid characters in identifiers are a little complex when you consider nontraditional characters such as Unicode. If you only consider typical ASCII alphanumeric characters, though, the rules are simple.

在JavaScript中，变量名（包括函数名）必须是有效的标识符。在标识符中，当你考虑非传统的字符时如字符编码，严格完整的规则对于有效的字符来说是有点复杂。如果你只是考虑典型的ASCII数字字母的字符，规则是很简单的。

An identifier must start with `a`-`z`, `A`-`Z`, `$`, or `_`. It can then contain any of those characters plus the numerals `0`-`9`.
一个标识符必须是以`a`-`z`,`A`-`z`,`$`,或者`_`开始。可以包含任何字符加上数字`0`-`9`。

Generally, the same rules apply to a property name as to a variable identifier. However, certain words cannot be used as variables, but are OK as property names. These words are called "reserved words," and include the JS keywords (`for`, `in`, `if`, etc.) as well as `null`, `true`, and `false`.
一般来说，同样的规则适用于属性名就变量标识符而言。然而，某些单词不能作为变量，但可以作为属性名。这些单词被称为“关键字”，包括JS关键字（`for`,`in`,`if`,等）以及`null`,`true`,和`false`。

**Note:** For more information about reserved words, see Appendix A of the *Types & Grammar* title of this series.
**注意:** 关于关键字的更多信息，请参考附录A中*类型&语法*系列的标题。

### 函数作用域(Function Scopes)

You use the `var` keyword to declare a variable that will belong to the current function scope, or the global scope if at the top level outside of any function.
使用`var`关键字去声明一个变量，它将会被添加到最近的函数作用域中，如果是在顶层以外的任何函数就被添加到全局作用域中。

#### 提升(Hoisting)

Wherever a `var` appears inside a scope, that declaration is taken to belong to the entire scope and accessible everywhere throughout.
只有一个`var`出现在一个作用域内，这个声明就被添加到属于整个作用域，在任何地方都可以访问的到。

Metaphorically, this behavior is called *hoisting*, when a `var` declaration is conceptually "moved" to the top of its enclosing scope. Technically, this process is more accurately explained by how code is compiled, but we can skip over those details for now.
用比喻的说法，把这种想象叫做*提升*，从概念上讲，“移动到”包含它的作用域中当一个`var`声明时。从技术上讲，这个过程更加准确的解释了如何编译代码，但是我们现在可以跳过这些细节。

Consider:
思考：

```js
var a = 2;

foo();					// works because `foo()`
						// declaration is "hoisted"

function foo() {
	a = 3;

	console.log( a );	// 3

	var a;				// declaration is "hoisted"
						// to the top of `foo()`
}

console.log( a );	// 2
```

**Warning:** It's not common or a good idea to rely on variable *hoisting* to use a variable earlier in its scope than its `var` declaration appears; it can be quite confusing. It's much more common and accepted to use *hoisted* function declarations, as we do with the `foo()` call appearing before its formal declaration.
**警告：** 使用一个变量在其作用域在`var`声明出现之前去依赖变量*提升*，这不是常见或者一个好的方法；它会让人困惑。更常见和接受的是使用*提升的*函数声明，如我们处理`foo()`函数调用出现在正式声明之前。

#### 嵌套的作用域(Nested Scopes) --翠翠

When you declare a variable, it is available anywhere in that scope, as well as any lower/inner scopes. For example:
当你声明一个变量，在那个作用域中任何地方它都是是可用的，以及在任何较低的/内部的作用域中。列如：

```js
function foo() {
	var a = 1;

	function bar() {
		var b = 2;

		function baz() {
			var c = 3;

			console.log( a, b, c );	// 1 2 3
		}

		baz();
		console.log( a, b );		// 1 2
	}

	bar();
	console.log( a );				// 1
}

foo();
```

Notice that `c` is not available inside of `bar()`, because it's declared only inside the inner `baz()` scope, and that `b` is not available to `foo()` for the same reason.
注意到变量`c`在函数`bar()`内是不可用的，因为变量`c`被声明仅仅是在函数`baz()`作用域内部，变量`b`对于函数`foo()`是不可用的也是同样的原因。

If you try to access a variable's value in a scope where it's not available, you'll get a `ReferenceError` thrown. If you try to set a variable that hasn't been declared, you'll either end up creating a variable in the top-level global scope (bad!) or getting an error, depending on "strict mode" (see "Strict Mode"). Let's take a look:
如果你试图访问一个变量的值在哪些作用域是不可用的，你将会得到一个`ReferenceError`抛出。如果你试图设置一个变量在它还没有被声明的时，根据“严格模式”（参考“严格模式”），你要么最终在顶层全局作用域（糟糕！）创建一个变量或者得到一个错误。让我们看一看：

```js
function foo() {
	a = 1;	// `a` not formally declared
}

foo();
a;			// 1 -- oops, auto global variable :(
```

This is a very bad practice. Don't do it! Always formally declare your variables.
这是一个非常糟糕的习惯。不要那样做！请总是正式声明你的变量。

In addition to creating declarations for variables at the function level, ES6 *lets* you declare variables to belong to individual blocks (pairs of `{ .. }`), using the `let` keyword. Besides some nuanced details, the scoping rules will behave roughly the same as we just saw with functions:
除了在函数级别对变量创建声明之外，ES6语法使用`let`关键字让你声明变量属于块级（成对的`{..}`）。除了一些细微的细节，作用域规则行为大致同我们下面看到的函数一样：

```js
function foo() {
	var a = 1;

	if (a >= 1) {
		let b = 2;

		while (b < 5) {
			let c = b * 2;
			b++;

			console.log( a + c );
		}
	}
}

foo();
// 5 7 9
```

Because of using `let` instead of `var`, `b` will belong only to the `if` statement and thus not to the whole `foo()` function's scope. Similarly, `c` belongs only to the `while` loop. Block scoping is very useful for managing your variable scopes in a more fine-grained fashion, which can make your code much easier to maintain over time.
因为使用了`let`而不是`var`,变量`b`将只属于`if`声明块级而不是整个`foo()`函数的作用域。同样的，变量`c`只属于`while`循环。在更细节的地方管理你的变量作用域，块级作用域是非常有用的，它可以使你的代码更容易维护。

**Note:** For more information about scope, see the *Scope & Closures* title of this series. See the *ES6 & Beyond* title of this series for more information about `let` block scoping.
**注意：** 关于作用域的更多信息，参见*作用域&闭包*系列的章节。关于`let`块级作用域的更多信息参见*ES6&Beyond*系列的章节。

## 条件语句（张雪）

In addition to the `if` statement we introduced briefly in Chapter 1, JavaScript provides a few other conditionals mechanisms that we should take a look at.
除了我们在第一章简要介绍过的 `if` 语句 ，我们还应该了解一下JavaScript提供的其他条件机制。

Sometimes you may find yourself writing a series of `if..else..if` statements like this:
有时候你会写一连串的`if..else..if`语句，像下面这样：

```js
if (a == 2) {
	// do something
}
else if (a == 10) {
	// do another thing
}
else if (a == 42) {
	// do yet another thing
}
else {
	// fallback to here
}
```

This structure works, but it's a little verbose because you need to specify the `a` test for each case. Here's another option, the `switch` statement:
这种程序结构能运行，但却又点冗余，你需要你需要在每个条件里明确指定`a`变量，下面是另一种写法，`switch`语句。

```js
switch (a) {
	case 2:
		// do something
		break;
	case 10:
		// do another thing
		break;
	case 42:
		// do yet another thing
		break;
	default:
		// fallback to here
}
```

The `break` is important if you want only the statement(s) in one `case` to run. If you omit `break` from a `case`, and that `case` matches or runs, execution will continue with the next `case`'s statements regardless of that `case` matching. This so called "fall through" is sometimes useful/desired:
如果你只想让语句在单一的`case`后面执行，就必须加上`break`。如果你在`case`后忽略了写`break`，不仅匹配了该`case`后的语句会被执行，其后面的每一个`case`后的语句不论是否匹配都会被执行。这种情况被称为“贯通”，有时候“贯通”是刻意为之的：

```js
switch (a) {
	case 2:
	case 10:
		// some cool stuff
		break;
	case 42:
		// other stuff
		break;
	default:
		// fallback
}
```

Here, if `a` is either `2` or `10`, it will execute the "some cool stuff" code statements.
这里，如果`a`是`2`或`10`，"some cool stuff"部分的代码会被执行。

Another form of conditional in JavaScript is the "conditional operator," often called the "ternary operator." It's like a more concise form of a single `if..else` statement, such as:
JavaScript中条件语句的另一种形式称作"条件运算符"，又常被称作"三元运算符"。它就像一个简洁版的单个`if..else`语句，如下：

```js
var a = 42;

var b = (a > 41) ? "hello" : "world";

// similar to:

// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

If the test expression (`a > 41` here) evaluates as `true`, the first clause (`"hello"`) results, otherwise the second clause (`"world"`) results, and whatever the result is then gets assigned to `b`.
如果测试的表达式(比如这里的 `a > 41`)为`true`，第一条字句(`"hello"`)就作为表达式的结果，否则就将第二条字句(`"world"`)作为表达式的结果，不论如何，表达式的结果都会被赋值给`b`。

The conditional operator doesn't have to be used in an assignment, but that's definitely the most common usage.
条件运算符并不一定要用在赋值语句中，但在赋值语句中使用条件运算符是一个非常常见的用法。

**Note:** For more information about testing conditions and other patterns for `switch` and `? :`, see the *Types & Grammar* title of this series.
**注意：** 关于条件判断的更多信息以及`switch`和`? :`的更多用法，参见章节*类型和语法*

## 严格模式(Strict Mode)

ES5 added a "strict mode" to the language, which tightens the rules for certain behaviors. Generally, these restrictions are seen as keeping the code to a safer and more appropriate set of guidelines. Also, adhering to strict mode makes your code generally more optimizable by the engine. Strict mode is a big win for code, and you should use it for all your programs.
ES5新增一个"严格模式"，这种模式限制了针对某些特定行为的规则。一般来说，这些限制能让代码保持安全而且更符合指导规范。而且，坚持执行严格模式让你的代码对编译引擎更加友好。严格模式对代码有很大益处，你应该在所有的代码中启用这一模式。

You can opt in to strict mode for an individual function, or an entire file, depending on where you put the strict mode pragma:
你能将严格模式应用于一个函数或整个文件，这取决你放置严格模式编译指示的位置：

```js
function foo() {
	"use strict";
  // 这里的代码是严格模式
	// this code is strict mode

	function bar() {
    // 这里的代码是严格模式
		// this code is strict mode
	}
}
// 这里的代码不是严格模式
// this code is not strict mode
```

Compare that to:
对比：

```js
"use strict";

function foo() {
  // 这里的代码是严格模式
	// this code is strict mode

	function bar() {
    // 这里的代码是严格模式
		// this code is strict mode
	}
}
// 这里的代码是严格模式
// this code is strict mode
```

One key difference (improvement!) with strict mode is disallowing the implicit auto-global variable declaration from omitting the `var`:
严格模式的一个关键的不同之处（也是改进之处）是不允许通过省略`var`进行隐式全局变量声明。

```js
function foo() {
	"use strict";	// 开启严格模式
	a = 1;			// 缺少 `var` , ReferenceError（引用错误）
}

foo();
```

If you turn on strict mode in your code, and you get errors, or code starts behaving buggy, your temptation might be to avoid strict mode. But that instinct would be a bad idea to indulge. If strict mode causes issues in your program, almost certainly it's a sign that you have things in your program you should fix.
如果你在你的代码里开启了严格模式，然后报出了错误，或是代码运行出问题，你可能就会去避免使用严格模式。让直觉纵容你的行动并不好，如果严格模式让你的程序出了问题，很可能是因为你的程序中有需要修复的地方。

Not only will strict mode keep your code to a safer path, and not only will it make your code more optimizable, but it also represents the future direction of the language. It'd be easier on you to get used to strict mode now than to keep putting it off -- it'll only get harder to convert later!
严格模式不仅让你的代码保持安全，让你的代码达到更加优化的状态，它也代表了这门语言未来的方向。比起以后不使用严格模式，现在熟悉严格模式会更简单，因为之后转换会更加困难。

**Note:** For more information about strict mode, see the Chapter 5 of the *Types & Grammar* title of this series.
**注意：** 关于严格模式的的更多信息，见第五节 *类型和语法*。

## 函数变量(Functions As Values)

So far, we've discussed functions as the primary mechanism of *scope* in JavaScript. You recall typical `function` declaration syntax as follows:
目前为止，我们将JavaScript中函数作为一种 *作用域* 机制，回忆一下如下的典型函数声明语法：

```js
function foo() {
	// ..
}
```

Though it may not seem obvious from that syntax, `foo` is basically just a variable in the outer enclosing scope that's given a reference to the `function` being declared. That is, the `function` itself is a value, just like `42` or `[1,2,3]` would be.
虽然可能从语法上看不出来，`foo`值是一个作用域的外部变量，这个变量指向被声明的`function`，没错，`function`本身就是一个值，就像`42`或`[1,2,3]`。

This may sound like a strange concept at first, so take a moment to ponder it. Not only can you pass a value (argument) *to* a function, but *a function itself can be a value* that's assigned to variables, or passed to or returned from other functions.
这个概念乍听起来比较奇怪，稍微花点时间琢磨一下。你不仅可以将一个值（参数）*传递* 给一个函数，而且函数本身可以被赋值给一个变量、作为别的函数的参数或返回值。

As such, a function value should be thought of as an expression, much like any other value or expression.
所以，一个函数值应该被当作一种表达式，正如其他的值或表达式：

Consider:
如下：

```js
var foo = function() {
	// ..
};

var x = function bar(){
	// ..
};
```

The first function expression assigned to the `foo` variable is called *anonymous* because it has no `name`.
第一个被赋值给了`foo`变量的函数表达式称作 *匿名函数*，因为他没有一个`名称`.

The second function expression is *named* (`bar`), even as a reference to it is also assigned to the `x` variable. *Named function expressions* are generally more preferable, though *anonymous function expressions* are still extremely common.
第二个函数表达式是一个*命名函数*(`bar`)，它甚至能作为一个引用被赋值给变量`x`。一般来说，使用命名函数更加合适，但匿名函数也非常常见。

For more information, see the *Scope & Closures* title of this series.
更多信息，参见章节 *作用域和闭包*

### 立即执行函数表达式(IIFEs) --张雪
### Immediately Invoked Function Expressions (IIFEs) （张雪）

In the previous snippet, neither of the function expressions are executed -- we could if we had included `foo()` or `x()`, for instance.
在之前的章节中，没有函数表达式并没有被执行，除非我们使用 `foo()` 或 `x()`。

There's another way to execute a function expression, which is typically referred to as an *immediately invoked function expression* (IIFE):
执行函数表达式还有别的方法，典型的有 *立即执行函数表达式* (IIFE)：

```js
(function IIFE(){
	console.log( "Hello!" );
})();
// "Hello!"
```

The outer `( .. )` that surrounds the `(function IIFE(){ .. })` function expression is just a nuance of JS grammar needed to prevent it from being treated as a normal function declaration.
外部的`( .. )`包裹着函数表达式`(function IIFE(){ .. })`是一种JS语法，防止函数表达式被当场一般的函数声明。

The final `()` on the end of the expression -- the `})();` line -- is what actually executes the function expression referenced immediately before it.
最后的`()`在表达式结尾的`})();`一行上，这才是真正执行之前包裹起来的函数表达式。

That may seem strange, but it's not as foreign as first glance. Consider the similarities between `foo` and `IIFE` here:
这些许看起来很奇怪，但第一眼看起来并不陌生。考虑一下如下`foo`和`IIFE`的区别：

```js
function foo() { .. }

// `foo`指向函数表达式
// `()`执行了这个表达式
// `foo` function reference expression,
// then `()` executes it
foo();

// `IIFE`函数表达式
// `()`执行了这个表达式
// `IIFE` function expression,
// then `()` executes it
(function IIFE(){ .. })();
```

As you can see, listing the `(function IIFE(){ .. })`before its executing `()` is essentially the same as including `foo` before its executing `()`; in both cases, the function reference is executed with `()` immediately after it.
正如你所看到的，将`(function IIFE(){ .. })`写在执行`()`之前和将`foo`定以后执行`()`一样重要，在两个例子中，函数都被之后的`()`执行了。

Because an IIFE is just a function, and functions create variable *scope*, using an IIFE in this fashion is often used to declare variables that won't affect the surrounding code outside the IIFE:
因为一个立即执行函数表达式只是一个函数，函数会创建一个变量的 *作用域*，立即执行函数表达式的这个特性常常会被用于声明变量，而且不会影响立即执行函数表达式外部的代码。

```js
var a = 42;

(function IIFE(){
	var a = 10;
	console.log( a );	// 10
})();

console.log( a );		// 42
```

IIFEs can also have return values:
立即执行函数表达式也可以有返回值

```js
var x = (function IIFE(){
	return 42;
})();

x;	// 42
```

The `42` value gets `return`ed from the `IIFE`-named function being executed, and is then assigned to `x`.
值`42`被立即执行函数表达式返回，然后被赋值给了变量`x`.

### Closure（张润）

*Closure* is one of the most important, and often least understood, concepts in JavaScript. I won't cover it in deep detail here, and instead refer you to the *Scope & Closures* title of this series. But I want to say a few things about it so you understand the general concept. It will be one of the most important techniques in your JS skillset.
*闭包* 是JavaScript中最重要的,也是经常被人不理解的概念之一.在这里我不会深入的解释它的概念,而是在*作用域 & 闭包*这个专题下详解这个系列。但是我想在这里简述一下它的概念,以便你对它有一个大致的了解。闭包是你掌握JS技能中最重要的技术之一。

You can think of closure as a way to "remember" and continue to access a function's scope (its variables) even once the function has finished running.

Consider:

```js
function makeAdder(x) {
	// parameter `x` is an inner variable

	// inner function `add()` uses `x`, so
	// it has a "closure" over it
	function add(y) {
		return y + x;
	};

	return add;
}
```

The reference to the inner `add(..)` function that gets returned with each call to the outer `makeAdder(..)` is able to remember whatever `x` value was passed in to `makeAdder(..)`. Now, let's use `makeAdder(..)`:
参考内部函数`add(..)`,在每次调用外部函数`makeAdder()`时都能够返回，并且记录`makeAdder()`所用过的`x`的值.现在,让我们开始使用`makAdder(...)`
```js
// `plusOne` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusOne = makeAdder( 1 );

// `plusTen` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusTen = makeAdder( 10 );

plusOne( 3 );		// 4  <-- 1 + 3
plusOne( 41 );		// 42 <-- 1 + 41

plusTen( 13 );		// 23 <-- 10 + 13
```

More on how this code works:
让我们看看这些代码是如何运行的：
1. When we call `makeAdder(1)`, we get back a reference to its inner `add(..)` that remembers `x` as `1`. We call this function reference `plusOne(..)`.
当我们调用 `makeAdder(1)`时，我们得到了一个它内部`add(...)`函数的引用,它记录了`x`变量1。我们将这个函数引用成为`plusOne(..)`
2. When we call `makeAdder(10)`, we get back another reference to its inner `add(..)` that remembers `x` as `10`. We call this function reference `plusTen(..)`.
当我们调用`makeAdder(10)`，我们得到了它另一个`add(...)`函数的引用，它记录了`x`变量10.我们将这个函数引用成为`plusTen(...)`
3. When we call `plusOne(3)`, it adds `3` (its inner `y`) to the `1` (remembered by `x`), and we get `4` as the result.
当我们调用 `plusOne(3)`，它将`3`(内部`y`)与`1`(`x`所存储的)相加，然后我们就得到了`4`作为结果输出。
4. When we call `plusTen(13)`, it adds `13` (its inner `y`) to the `10` (remembered by `x`), and we get `23` as the result.

Don't worry if this seems strange and confusing at first -- it can be! It'll take lots of practice to understand it fully.
如果一开始感觉困惑和奇怪没什么好担心的--那很正常！想要完全的理解仍需做更多的练习。

But trust me, once you do, it's one of the most powerful and useful techniques in all of programming. It's definitely worth the effort to let your brain simmer on closures for a bit. In the next section, we'll get a little more practice with closure.
相信我，一旦你掌握了这些，在所有的编程中这些都是最有用的技巧。让你们的慢慢理解一点闭包的知识是完全有必要的。我们将练习更多的有关闭包的内容。

#### 模块(Modules)

The most common usage of closure in JavaScript is the module pattern. Modules let you define private implementation details (variables, functions) that are hidden from the outside world, as well as a public API that *is* accessible from the outside.
JavaScript中最常用到闭包的是在模块模式中。模块让你能够定义私有的操作细节(变量，函数)，从而能够与外部隔离，即定义一个公共的能与外部通信的API接口.

Consider:

```js
function User(){
	var username, password;

	function doLogin(user,pw) {
		username = user;
		password = pw;

		// do the rest of the login work
	}

	var publicAPI = {
		login: doLogin
	};

	return publicAPI;
}

// create a `User` module instance
var fred = User();

fred.login( "fred", "12Battery34!" );
```

The `User()` function serves as an outer scope that holds the variables `username` and `password`, as well as the inner `doLogin()` function; these are all private inner details of this `User` module that cannot be accessed from the outside world.
`User`函数和其内部的函数`doLogin()`提供了一个外部的作用域，能够接收变量`username`和`password`,这些都是`User`模块私有的内部细节，不能被外界访问。

**Warning:** We are not calling `new User()` here, on purpose, despite the fact that probably seems more common to most readers. `User()` is just a function, not a class to be instantiated, so it's just called normally. Using `new` would be inappropriate and actually waste resources.
**警告：** 我们在这里有意没有调用`new User()`，排除一些大多数读者可能遇到的可能性因素。`User()`仅仅是一个函数，而不是一个待实例化的类，因此这里只是用常规的方法调用它。使用`new`不必要且浪费资源。

Executing `User()` creates an *instance* of the `User` module -- a whole new scope is created, and thus a whole new copy of each of these inner variables/functions. We assign this instance to `fred`. If we run `User()` again, we'd get a new instance entirely separate from `fred`.
执行`User`创建了`User`模块的一个实例 -- 一整个新的作用域被创建了,即产生了以一个全新的内部变量和函数的拷贝。我们将其标示为`fred`.如果我们再跑一边`User()`，我们将获得一个全新的与`fred`无关的实例。

The inner `doLogin()` function has a closure over `username` and `password`, meaning it will retain its access to them even after the `User()` function finishes running.
内部函数`doLogin`在`username`和`password`上产生了闭包，意味着它将保留对`username`和`password`的访问，即便`User()`函数已经运行完毕

`publicAPI` is an object with one property/method on it, `login`, which is a reference to the inner `doLogin()` function. When we return `publicAPI` from `User()`, it becomes the instance we call `fred`.
`publicAPI` 是一个有着恰当的方法的对象，`login`,是一个内部函数`doLogin`的引用。当我们在`User()`方法中返回`publicAPI`时，`login`就变成了`fred`实例.

At this point, the outer `User()` function has finished executing. Normally, you'd think the inner variables like `username` and `password` have gone away. But here they have not, because there's a closure in the `login()` function keeping them alive.
就这点来说，外部函数`User`运行完毕.通常来说，你可能以为内部变量，像`username`和`password`已经不存在了。事实却并非如此，因为内部函数`login()`形成的闭包使它们仍然存在.

That's why we can call `fred.login(..)` -- the same as calling the inner `doLogin(..)` -- and it can still access `username` and `password` inner variables.
这就是为什么我们称之为`fred.login()` -- 也称之为内部`doLogin(..)` -- 仍旧能够访问内部变量`username`和`password`

There's a good chance that with just this brief glimpse at closure and the module pattern, some of it is still a bit confusing. That's OK! It takes some work to wrap your brain around it.
这是简单浏览闭包和模块化编程的一个很好的机会，其中的一些知识可能仍旧让人感到困惑。不要担心!这些内容主要目的在于能够在你的思维中留下一些印象。

From here, go read the *Scope & Closures* title of this series for a much more in-depth exploration.
至此，如需深入了解则可以阅读*Scope & Closures* 章节。

## `this` 标识符(`this` Identifier) --李欣

Another very commonly misunderstood concept in JavaScript is the `this` identifier. Again, there's a couple of chapters on it in the *this & Object Prototypes* title of this series, so here we'll just briefly introduce the concept.
在JavaScript中另一个容易被无解的概念是`this`标识符。在这个系列的*this & Object Prototypes*书中有几章是会着重阐述这个概念，所以在这里我们只是简单介绍这个概念

While it may often seem that `this` is related to "object-oriented patterns," in JS `this` is a different mechanism.
虽然`this`看起来经常跟“面向对象模式（object-oriented patterns）”有关，但是在JS中，`this`有着不同的处理机制。

If a function has a `this` reference inside it, that `this` reference usually points to an `object`. But which `object` it points to depends on how the function was called.
如果在一个函数中有一个`this`引用，通常这个`this`引用指向一个`object`。但是它具体指向哪个`object`取决于这个函数是如何被调用的。

It's important to realize that `this` *does not* refer to the function itself, as is the most common misconception.
`this` *并不是* 指向函数本身，这是一个很容易产生误解的地方，需要着重区分。

Here's a quick illustration:
下面是一段示例代码

```js
function foo() {
	console.log( this.bar );
}

var bar = "global";

var obj1 = {
	bar: "obj1",
	foo: foo
};

var obj2 = {
	bar: "obj2"
};

// --------

foo();				// "global"
obj1.foo();			// "obj1"
foo.call( obj2 );	// "obj2"
new foo();			// undefined
```

There are four rules for how `this` gets set, and they're shown in those last four lines of that snippet.
在上述代码的最后四行显示了`this`在4种不同形势下被设置成了什么。

1. `foo()` ends up setting `this` to the global object in non-strict mode -- in strict mode, `this` would be `undefined` and you'd get an error in accessing the `bar` property -- so `"global"` is the value found for `this.bar`.
1. 在非严格模式下`foo()`将`this`设置成全局对象，所以`this.bar`的值是`“global”`。如果是严格模式，`this`将被设置为`undefined`，同时你在访问`bar`属性时会产生错误信息，

2. `obj1.foo()` sets `this` to the `obj1` object.
2. `obj1.foo()`将`this`指向`obj1`对象。

3. `foo.call(obj2)` sets `this` to the `obj2` object.
3. `foo.call(obj2)`将`this`指向`obj2`对象。

4. `new foo()` sets `this` to a brand new empty object.
4. `foo.call(obj2)`将`this`指向一个全新的对象。

Bottom line: to understand what `this` points to, you have to examine how the function in question was called. It will be one of those four ways just shown, and that will then answer what `this` is.
概要：想要理解`this`到底指向什么，你必须检查函数是如何被调用的。无外乎上述的4种形式之一，如果你理解了函数如何被调用的，你就会知道`this`指向什么。


**Note:** For more information about `this`, see Chapters 1 and 2 of the *this & Object Prototypes* title of this series.
**注意：** 想要获取更过关于`this`的信息，请查阅本系列丛书中标题为*this和对象属性*的第一、二章

## 属性(Prototypes)

The prototype mechanism in JavaScript is quite complicated. We will only glance at it here. You will want to spend plenty of time reviewing Chapters 4-6 of the *this & Object Prototypes* title of this series for all the details.
在JavaScript中属性机制十分复杂，这里我们只需了解大概即可。如果你想了解更加详细的信息，可以通过本系列丛书中*this & 对象属性*的第四至第六章来获取。

When you reference a property on an object, if that property doesn't exist, JavaScript will automatically use that object's internal prototype reference to find another object to look for the property on. You could think of this almost as a fallback if the property is missing.
在JavaScript中，当你在一个对象中引用一个不存在的对象的时候，JS会自动通过该对象内部的原型引用从另一个对象中去寻找这个属性。如果这个属性缺失，你可以认为是一个回退

The internal prototype reference linkage from one object to its fallback happens at the time the object is created. The simplest way to illustrate it is with a built-in utility called `Object.create(..)`.
在对象创建的时候会将该对象和其内部原型链所指向的回退对象相关联。解释它最好的例子就是用`Object.creat(...)`这个内置方法

Consider:
考虑下面的代码：

```js
var foo = {
	a: 42
};

// create `bar` and link it to `foo`
var bar = Object.create( foo );

bar.b = "hello world";

bar.b;		// "hello world"
bar.a;		// 42 <-- delegated to `foo`
```

It may help to visualize the `foo` and `bar` objects and their relationship:
下面这幅图可以更直观的展示`foo`对象和`bar`对象以及他们之间的关系

<img src="./images/chapter2/fig6.png">

The `a` property doesn't actually exist on the `bar` object, but because `bar` is prototype-linked to `foo`, JavaScript automatically falls back to looking for `a` on the `foo` object, where it's found.
对象`b`实际上并不存在`a`属性，但是`bar`的原型链指向`foo`，JavaScript会自动回退到`foo`对象上去寻找并最终找到`a`属性。

This linkage may seem like a strange feature of the language. The most common way this feature is used -- and I would argue, abused -- is to try to emulate/fake a "class" mechanism with "inheritance."
这种链接形式在编程语言中看起来很奇怪。我认为这个特性在试图仿照“类”中的“继承”机制的时候被过分滥用。

But a more natural way of applying prototypes is a pattern called "behavior delegation," where you intentionally design your linked objects to be able to *delegate* from one to the other for parts of the needed behavior.
另一种更自然的应用原型的方式是一种被称作“行为委托”的模式，在这种模式下， 对于那些被链接的对象，可以将某些必须的行为从其中一个*委托*给其他对象来实现

**Note:** For more information about prototypes and behavior delegation, see Chapters 4-6 of the *this & Object Prototypes* title of this series.
**注意：** 想要获取更过关于属性和行为委托的信息，请查阅本系列丛书中标题为*this和对象属性*的第四至第六章

## 旧和新(Old & New)

Some of the JS features we've already covered, and certainly many of the features covered in the rest of this series, are newer additions and will not necessarily be available in older browsers. In fact, some of the newest features in the specification aren't even implemented in any stable browsers yet.
我们已经介绍了JS的一些特性，在本系列其余部分中介绍的许多特性都是比较新的附加特性，在旧版本的浏览器中并不一定可用`。事实上，规范中的一些最新的特性甚至在主流的浏览器中都没有实现

So, what do you do with the new stuff? Do you just have to wait around for years or decades for all the old browsers to fade into obscurity?
那么，你想怎样使用新工具呢？难道只是等着若干年后所有老旧的浏览器退出人们的视野吗？

That's how many people think about the situation, but it's really not a healthy approach to JS.
绝大多数的人都是这么想的，但这并不是一个深入js的好途径

There are two main techniques you can use to "bring" the newer JavaScript stuff to the older browsers: polyfilling and transpiling.
现在有两种主要的技术可以将JavaScript的新特性带入到旧版本的浏览器中：polyfilling 和 transpiling

### Polyfilling

The word "polyfill" is an invented term (by Remy Sharp) (https://remysharp.com/2010/10/08/what-is-a-polyfill) used to refer to taking the definition of a newer feature and producing a piece of code that's equivalent to the behavior, but is able to run in older JS environments.
"polyfill"是Remy Sharp发明的术语(https://remysharp.com/2010/10/08/what-is-a-polyfill)，用来指代一段可以将新特性运行在旧的js环境中的代码块

For example, ES6 defines a utility called `Number.isNaN(..)` to provide an accurate non-buggy check for `NaN` values, deprecating the original `isNaN(..)` utility. But it's easy to polyfill that utility so that you can start using it in your code regardless of whether the end user is in an ES6 browser or not.
`举个例子，ES6定义了一个叫做`Number.isNaN(..)`的工具函数并且不再支持原始的`isNaN(..)`方法，它可以准确的判断被检查的值是不是`NaN`，但是可以很容易的通过polyfill来实现这个方法，所以你可以在你的代码中使用他不管用户是否在使用支持es6的浏览器`

Consider:
考虑下面的代码：

```js
if (!Number.isNaN) {
	Number.isNaN = function isNaN(x) {
		return x !== x;
	};
}
```

The `if` statement guards against applying the polyfill definition in ES6 browsers where it will already exist. If it's not already present, we define `Number.isNaN(..)`.
`if`语句防止在支持ES6语法的浏览器中应用polyfill定义。 如果它不存在，我们定义`Number.isNaN(..)`。

**Note:** The check we do here takes advantage of a quirk with `NaN` values, which is that they're the only value in the whole language that is not equal to itself. So the `NaN` value is the only one that would make `x !== x` be `true`.
**注意：** 我们在这里的检查利用了`NaN`类型值的一个古怪特性，在整个语言中，它是唯一不等于自身的值类型。 所以`NaN`是唯一可以令`x !== x`返回`true`的值类型

Not all new features are fully polyfillable. Sometimes most of the behavior can be polyfilled, but there are still small deviations. You should be really, really careful in implementing a polyfill yourself, to make sure you are adhering to the specification as strictly as possible.
并不是所有的新特性都可以通过polyfill来定义。有时绝大部分的行为可以通过polyfill来定义，但仍旧会有一些偏差。你在自己实现polyfill的时候一定要慎之又慎，确保严格遵守规范。

Or better yet, use an already vetted set of polyfills that you can trust, such as those provided by ES5-Shim (https://github.com/es-shims/es5-shim) and ES6-Shim (https://github.com/es-shims/es6-shim).
还有一种更好的方法，使用你可以信任的已经审查过的polyfills，比如ES5-Shim(https://github.com/es-shims/es5-shim)和ES6-Shim(https://github.com/es-shims/es6-shim)所提供的polyfills

### Transpiling

There's no way to polyfill new syntax that has been added to the language. The new syntax would throw an error in the old JS engine as unrecognized/invalid.
被添加到语言中的新语法没有办法被polyfill。 在就的js引擎中，新语法会抛出一个unrecognized或invalid的错误提示

So the better option is to use a tool that converts your newer code into older code equivalents. This process is commonly called "transpiling," a term for transforming + compiling.
所以最好的方式是通过工具来将你的新代码转换成等价的旧代码，这个过程通常被称作"transpiling"，一个transforming和compiling相结合的术语

Essentially, your source code is authored in the new syntax form, but what you deploy to the browser is the transpiled code in old syntax form. You typically insert the transpiler into your build process, similar to your code linter or your minifier.
实质上，你的源码是以新的语法形式创建的，但是部属到浏览器上的是转换后的旧的语法形式。通常将转换器插入构建过程，这有点类似代码校验（linter）或代码压缩（minifier）。

You might wonder why you'd go to the trouble to write new syntax only to have it transpiled away to older code -- why not just write the older code directly?
你可能想知道为什么要去写那些最终会被转换为旧代码的新语法，为什么不直接写老代码呢？

There are several important reasons you should care about transpiling:
你关心transpiling有几个重要的原因：

* The new syntax added to the language is designed to make your code more readable and maintainable. The older equivalents are often much more convoluted. You should prefer writing newer and cleaner syntax, not only for yourself but for all other members of the development team.
* 添加到语言中的新语法旨在让你的代码变的更容易阅读和维护。老的等价代码通常更复杂。你应该更喜欢书写更新和更干净的语法，不仅是为了你自己，也是为了开发团队中的其他成员
* If you transpile only for older browsers, but serve the new syntax to the newest browsers, you get to take advantage of browser performance optimizations with the new syntax. This also lets browser makers have more real-world code to test their implementations and optimizations on.
* 如果你只对老旧的浏览器进行transpile，提供新语法给新的浏览器，你可以通过新语法的优势来获取浏览器性能上的优化。同时，这也可以帮助浏览器厂家用更多的真实代码来测试他们的实现和优化。
* Using the new syntax earlier allows it to be tested more robustly in the real world, which provides earlier feedback to the JavaScript committee (TC39). If issues are found early enough, they can be changed/fixed before those language design mistakes become permanent.
* 更早的使用新语法允许在现实世界中对其进行更强大的测试，这为JavaScript委员会(TC39)提供了更早的反馈信息。如果issues被更早的发现，他们可以在发布前对语言设计错误进行更改/修正

Here's a quick example of transpiling. ES6 adds a feature called "default parameter values." It looks like this:
这里有一个transpiling的例子。ES6添加了一个叫做“默认值”的功能，示例如下

```js
function foo(a = 2) {
	console.log( a );
}

foo();		// 2
foo( 42 );	// 42
```

Simple, right? Helpful, too! But it's new syntax that's invalid in pre-ES6 engines. So what will a transpiler do with that code to make it run in older environments?
是不是很简单也很有帮助？但是这个新语法在ES6之前的引擎中无效，所以转码器将如何转换该代码使其在较旧的环境中运行？

```js
function foo() {
	var a = arguments[0] !== (void 0) ? arguments[0] : 2;
	console.log( a );
}
```

As you can see, it checks to see if the `arguments[0]` value is `void 0` (aka `undefined`), and if so provides the `2` default value; otherwise, it assigns whatever was passed.
正如你看到的，它会检查`arguments[0]`的值是否是`void 0` (等同于`undefined`)， 如果是，则将默认值2赋值给变量a；如果不是，则将传递的参数分配给变量a

In addition to being able to now use the nicer syntax even in older browsers, looking at the transpiled code actually explains the intended behavior more clearly.
除了能够在旧的浏览器中提供更好的语法，查看转换后的代码实际上更清楚的解释了预期的行为。

You may not have realized just from looking at the ES6 version that `undefined` is the only value that can't get explicitly passed in for a default-value parameter, but the transpiled code makes that much more clear.
在ES6版本中，你可能没有意识到`undefined`是唯一的不能显示传递默认值的参数，但是转译后的代码则可以让你更清楚的看到这个特性。

The last important detail to emphasize about transpilers is that they should now be thought of as a standard part of the JS development ecosystem and process. JS is going to continue to evolve, much more quickly than before, so every few months new syntax and new features will be added.
强调转换器的最后一个重要细节是，它们现在应该被认为是JS开发生态系统和过程的标准部分。 JS将比以前更快的发展，，因此每几个月就会有添加新的语法和新功能被添加进来。

If you use a transpiler by default, you'll always be able to make that switch to newer syntax whenever you find it useful, rather than always waiting for years for today's browsers to phase out.
如果你默认使用一个转换器，你就总是能够在发现它有用的时候切换到更新的语法，而不是总是等待今天的浏览器被逐步淘汰。

There are quite a few great transpilers for you to choose from. Here are some good options at the time of this writing:
有很多伟大的转译器可供你选择。 这里写一些好的选择：

* Babel (https://babeljs.io) (formerly 6to5): Transpiles ES6+ into ES5
* Traceur (https://github.com/google/traceur-compiler): Transpiles ES6, ES7, and beyond into ES5

## 非JavaScript(Non-JavaScript)

So far, the only things we've covered are in the JS language itself. The reality is that most JS is written to run in and interact with environments like browsers. A good chunk of the stuff that you write in your code is, strictly speaking, not directly controlled by JavaScript. That probably sounds a little strange.
到目前为止，我们所覆盖的唯一的东西是在JS语言本身。 现实是大多数JS被编写为在浏览器等环境中运行和交互。 严格来说，在你的代码中写的很多东西不是由JavaScript直接控制。 这听起来可能有点奇怪。

The most common non-JavaScript JavaScript you'll encounter is the DOM API. For example:
您会遇到的最常见的非JavaScript的JavaScript是DOM API。 例如：

```js
var el = document.getElementById( "foo" );
```

The `document` variable exists as a global variable when your code is running in a browser. It's not provided by the JS engine, nor is it particularly controlled by the JavaScript specification. It takes the form of something that looks an awful lot like a normal JS `object`, but it's not really exactly that. It's a special `object,` often called a "host object."
当你的代码在浏览器中运行时，`document`变量作为一个全局变量存在。 它不是由JS引擎提供，也不是由JavaScript规范特别控制。 它的形式看起来像一个普通的JS`object`，但它完全是真的`object`。 它是一个特殊的`object`，通常称为“宿主对象”。

Moreover, the `getElementById(..)` method on `document` looks like a normal JS function, but it's just a thinly exposed interface to a built-in method provided by the DOM from your browser. In some (newer-generation) browsers, this layer may also be in JS, but traditionally the DOM and its behavior is implemented in something more like C/C++.
而且，`document`上的`getElementById（..）`方法看起来像一个普通的JS函数，但它只是一个暴露的接口，它是由浏览器的DOM提供的内置方法。 在一些（新一代）浏览器中，这层也可以是JS，但是传统上DOM和它的行为更像C / C ++那样被实现。

Another example is with input/output (I/O).
另一个例子是输入/输出

Everyone's favorite `alert(..)` pops up a message box in the user's browser window. `alert(..)` is provided to your JS program by the browser, not by the JS engine itself. The call you make sends the message to the browser internals and it handles drawing and displaying the message box.
大家都最喜欢的“alert（..）”会在用户的浏览器窗口中弹出一个消息框。 `alert（..）`是由浏览器提供给你的JS程序，而不是JS引擎本身。 你所做的只是将消息发送到浏览器内部，浏览器来处理绘制和显示消息框。

The same goes with `console.log(..)`; your browser provides such mechanisms and hooks them up to the developer tools.
同样的是`console.log（..）`; 你的浏览器提供这样的机制，并将它们挂钩到开发者工具上。

This book, and this whole series, focuses on JavaScript the language. That's why you don't see any substantial coverage of these non-JavaScript JavaScript mechanisms. Nevertheless, you need to be aware of them, as they'll be in every JS program you write!
这本书，这整个系列，聚焦在JavaScript的语言本身。 这就是为什么你看不到这些非JavaScript机制的实质性覆盖。 然而，你还是需要了解他们，因为他们会出现在你写的每个JS程序里！

## 回顾(Review)

The first step to learning JavaScript's flavor of programming is to get a basic understanding of its core mechanisms like values, types, function closures, `this`, and prototypes.
学习JavaScript编程的第一步是获得对其核心机制（如值，类型，函数闭包，“this”和原型）的基本理解。

Of course, each of these topics deserves much greater coverage than you've seen here, but that's why they have chapters and books dedicated to them throughout the rest of this series. After you feel pretty comfortable with the concepts and code samples in this chapter, the rest of the series awaits you to really dig in and get to know the language deeply.
当然，这些主题每个都比你在这里看到的覆盖面更大，但这就是为什么他们在这一系列的其余部分有专门的章节和书籍的原因。 在你对本章中的概念和代码示例能够很容易掌握之后，系列的其余部分等待你真正深入挖掘并深入了解语言本身。

The final chapter of this book will briefly summarize each of the other titles in the series and the other concepts they cover besides what we've already explored.
本书的最后一章将简要总结本系列中的其他书名以及除了我们已经探讨的其他概念。

## 单词本
|  单词  |  音标   |  释义 |
| --- | --- | --- |
| addition | [ə'dɪʃən] | n. 附加物（addition的复数）；附件；增加固定资产 |
| specification | ['spɛsəfə'keʃən] | n. 规格；说明书；详述 |
| obscurity | [əb'skjʊrəti] | n. 朦胧；阴暗；晦涩；身份低微；不分明 |
| equivalent | [ɪ'kwɪvələnt] | adj. 等价的，相等的；同意义的 n. 等价物，相等物 |
| accurate | [/'ækjɚət/] | 准确 |
| non-buggy |  | |
| deprecating | ['dɛprəketɪŋ] | adj. 不以为然的；不赞成的 v. 对…表示不赞成；轻视（deprecate的ing形式）|
| regardless | [rɪ'ɡɑrdləs] | adj. 不管的；不顾的；不注意的 adv. 不顾后果地；不管怎样，无论如何；不惜费用地 |
| guards against | | 防止；提防 |
| advantage | [əd'væntɪdʒ] | n. 优势；利益；有利条件 vi. 获利 vt. 有利于；使处于优势 |
| quirk | [kwɝk] | n. 怪癖；急转；借口 |
| deviation | [,di:vi'eiʃən] | n. 差异，偏差 |
| adhering | [əd'hɪr] | adj. 附着，粘附性的；[物] 粘附的 |
| vet | [vɛt] | vt. 审查；诊疗 |
| set of polyfills | | 一组polyfills |
| term | [tɝm] | n. 术语；学期；期限；条款；(代数式等的)项 |
| essentially | [ɪ'sɛnʃəli] | adv. 本质上；本来 |
| typically | ['tɪpɪkli] | adv. 代表性地；作为特色地 |
| maintainable | [mein'teinəbl] | adj. 可维持的；可主张的；可维修的 |
| equivalents | [i'kwivələnt] | n. 等价物，相等物 |
| convoluted | ['kɑnvəlutɪd] | adj. 复杂的；费解的；旋绕的 |
| robustly | [rəu'bʌstli] | adv. 要用体力地；粗鲁地；坚定地 |
| committee  | [kə'mɪti] | n. 委员会 |
| permanent | ['pɝmənənt] | adj. 永久的，永恒的；不变的 |
| In addition to | |除…之外 |
| intend | [in'tend] | 打算 |
| explicitly | [ɪk'splɪsɪtli] | adv. 明确地；明白地 |
| ecosystem | ['ɛko,sɪstəm] | n. 生态系统 |
| emphasize | ['ɛmfəsaɪz] | vt. 强调，着重 |
| evolve | [ɪ'vɑlv] | vt. 发展，进化；进化；使逐步形成；推断出 |
| phase out | | 使逐步淘汰；逐渐停止 |
| particularly | [pɚ'tɪkjəlɚli] |   adv. 特别地，独特地；详细地，具体地；明确地，细致地 |
| exposed | [ɪk'spozd] | adj. 暴露的，无掩蔽的 |
| layer | ['leɪr] | n. 层，层次；膜； |
| traditionally | [trə'diʃənəli] | adv. 传统上；习惯上；传说上 |
| mechanisms | ['mɛkənɪzəmz] | n. 机制； |
| substantial | [səbˈstænʃəl] | adj. 大量的；实质的；内容充实的 n. 本质；重要材料 |
| Nevertheless | [,nɛvɚðə'lɛs] | adv. 然而，不过；虽然如此 |
| be aware of | | 知道 |
| deserves | [dɪ'zɝvs] | 应受 |
| dedicated | ['dɛdə'ketɪd] | adj. 专用的；专注的；献身的 |
| pragma | [p'ræɡmə] | n. 编译指示；杂注 |
| scope  | [skəup] | n. 范围；余地；视野；眼界；导弹射程 vt. 审视 |
| declaration | [,deklə'reiʃən] | n. 声明， |
